Directory Structure:

└── ./
    └── infinite_canvas_v5
        ├── api
        │   └── replicate-proxy.js
        ├── public
        │   └── icons
        │       ├── font-decrease.svg
        │       ├── font-increase.svg
        │       ├── redo.svg
        │       ├── reset-view.svg
        │       ├── undo.svg
        │       ├── zoom-in.svg
        │       └── zoom-out.svg
        ├── src
        │   ├── AIManager.js
        │   ├── aiService.js
        │   ├── canvasRenderer.js
        │   ├── CanvasState.js
        │   ├── InfiniteCanvasSimple.js
        │   ├── InputHandler.js
        │   ├── markdownParser.js
        │   ├── markdownRenderer.js
        │   └── UIManager.js
        ├── .gitignore
        ├── index.html
        ├── main.js
        ├── package-lock.json
        ├── package.json
        ├── README.md
        ├── replicate-proxy.js
        ├── style.css
        ├── vercel.json
        └── vite.config.js



---
File: /infinite_canvas_v5/api/replicate-proxy.js
---

import fetch from 'node-fetch';

// Helper function to get the appropriate aspect ratio format for different models
function getModelAspectRatio(model, requestedAspectRatio) {
    // Map of models to their supported aspect ratio formats
    const modelAspectRatioMaps = {
        'recraft-ai/recraft-v3': {
            '1:1': '1:1',
            '16:9': '16:9', 
            '9:16': '9:16'
        },
        'google/imagen-4': {
            '1:1': '1:1',
            '16:9': '16:9',
            '9:16': '9:16'
        },
        'bytedance/seedream-3': {
            '1:1': '1:1',
            '16:9': '16:9',
            '9:16': '9:16'
        }
    };

    const modelMap = modelAspectRatioMaps[model];
    if (modelMap && modelMap[requestedAspectRatio]) {
        return modelMap[requestedAspectRatio];
    }
    
    // Default fallback
    return '1:1';
}

// Helper function to get the appropriate model endpoint
function getModelEndpoint(model) {
    const endpoints = {
        'recraft-ai/recraft-v3': 'https://api.replicate.com/v1/models/recraft-ai/recraft-v3/predictions',
        'google/imagen-4': 'https://api.replicate.com/v1/models/google/imagen-4/predictions',
        'bytedance/seedream-3': 'https://api.replicate.com/v1/models/bytedance/seedream-3/predictions'
    };
    
    return endpoints[model] || endpoints['bytedance/seedream-3']; // fallback
}

// Helper function to create model-specific input parameters
function createModelInput(model, prompt, aspectRatio) {
    const mappedAspectRatio = getModelAspectRatio(model, aspectRatio);
    
    switch (model) {
        case 'recraft-ai/recraft-v3':
            return {
                prompt,
                aspect_ratio: mappedAspectRatio,
                style: 'any'
            };
        
        case 'google/imagen-4':
            return {
                prompt,
                aspect_ratio: mappedAspectRatio,
                safety_filter_level: 'block_medium_and_above',
                output_format: 'png'
            };
        
        case 'bytedance/seedream-3':
        default:
            return {
                prompt,
                size: 'regular',
                aspect_ratio: mappedAspectRatio,
                guidance_scale: 3.5
            };
    }
}

// Helper function to handle CORS
function setCorsHeaders(res) {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
}

// Main handler function for Vercel
export default async function handler(req, res) {
    setCorsHeaders(res);
    
    // Handle preflight requests
    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    const { url } = req;
    
    try {
        if (url.includes('/api/replicate-image')) {
            await handleImageGeneration(req, res);
        } else if (url.includes('/api/replicate-context')) {
            await handleContextEdit(req, res);
        } else if (url.includes('/api/replicate-poll')) {
            await handlePoll(req, res);
        } else if (url.includes('/api/replicate-video')) {
            await handleVideoGeneration(req, res);
        } else if (url.includes('/api/replicate-gen4')) {
            await handleGen4(req, res);
        } else {
            res.status(404).json({ error: 'Endpoint not found' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
}

// Handle image generation
async function handleImageGeneration(req, res) {
    const { prompt, replicateApiKey, model = 'bytedance/seedream-3', aspectRatio = '1:1' } = req.body;
    if (!prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing prompt or replicateApiKey' });
    }
    
    const endpoint = getModelEndpoint(model);
    const input = createModelInput(model, prompt, aspectRatio);
    
    const body = { input };
    
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${replicateApiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
    });
    const data = await response.json();
    res.status(response.status).json(data);
}

// Handle context image editing
async function handleContextEdit(req, res) {
    const { imageUrl, prompt, replicateApiKey, aspectRatio = 'match_input_image' } = req.body;
    if (!imageUrl || !prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing imageUrl, prompt, or replicateApiKey' });
    }
    
    const endpoint = 'https://api.replicate.com/v1/models/black-forest-labs/flux-kontext-pro/predictions';
    const body = {
        input: {
            input_image: imageUrl,
            prompt: prompt,
            aspect_ratio: aspectRatio,
            output_format: "png",
            output_quality: 80,
            safety_tolerance: 2
        }
    };
    
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${replicateApiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
    });
    const data = await response.json();
    res.status(response.status).json(data);
}

// Handle polling for prediction status
async function handlePoll(req, res) {
    const { getUrl, replicateApiKey } = req.body;
    if (!getUrl || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing getUrl or replicateApiKey' });
    }
    
    const response = await fetch(getUrl, {
        headers: { 'Authorization': `Bearer ${replicateApiKey}` }
    });
    const data = await response.json();
    res.status(response.status).json(data);
}

// Handle video generation
async function handleVideoGeneration(req, res) {
    const { prompt, imageUrl, replicateApiKey } = req.body;
    if (!prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing prompt or replicateApiKey' });
    }
    
    const endpoint = 'https://api.replicate.com/v1/models/bytedance/seedance-1-pro/predictions';
    const body = {
        input: {
            prompt: prompt,
            duration: 5,
            resolution: "1080p",
            aspect_ratio: "16:9",
            fps: 24,
            camera_fixed: false
        }
    };
    
    // If imageUrl is provided, add it for image-to-video generation
    if (imageUrl) {
        body.input.image = imageUrl;
    }
    
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${replicateApiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
    });
    const data = await response.json();
    res.status(response.status).json(data);
}

// Handle RunwayML Gen-4 with reference images
async function handleGen4(req, res) {
    const { prompt, referenceImages, referenceTags, replicateApiKey, aspectRatio = '1:1' } = req.body;
    
    if (!prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing prompt or replicateApiKey' });
    }
    
    if (!replicateApiKey.startsWith('r8_')) {
        return res.status(400).json({ error: 'Invalid Replicate API key' });
    }
    
    if (referenceImages && referenceImages.length > 3) {
        return res.status(400).json({ error: 'Maximum 3 reference images allowed' });
    }
    
    const endpoint = 'https://api.replicate.com/v1/models/runwayml/gen4-image/predictions';
    const body = {
        input: {
            prompt: prompt,
            resolution: "1080p",
            aspect_ratio: aspectRatio
        }
    };
    
    // Add reference images and tags if provided
    if (referenceImages && referenceImages.length > 0) {
        body.input.reference_images = referenceImages;
    }
    
    if (referenceTags && referenceTags.length > 0) {
        body.input.reference_tags = referenceTags;
    }
    
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${replicateApiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
    });
    
    const data = await response.json();
    res.status(response.status).json(data);
}


---
File: /infinite_canvas_v5/public/icons/font-decrease.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 16L6.5 6L10 16" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M4.5 13H8.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <circle cx="15" cy="10" r="4" stroke="currentColor" stroke-width="1.5" fill="none"/>
  <path d="M13 10H17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
</svg>


---
File: /infinite_canvas_v5/public/icons/font-increase.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 16L6.5 6L10 16" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M4.5 13H8.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <circle cx="15" cy="10" r="4" stroke="currentColor" stroke-width="1.5" fill="none"/>
  <path d="M15 8V12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <path d="M13 10H17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
</svg>


---
File: /infinite_canvas_v5/public/icons/redo.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M17 7L13 3L13 5.5C8.85786 5.5 5.5 8.85786 5.5 13C5.5 14.3807 5.88071 15.6651 6.54025 16.7743" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M17 7L13 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>


---
File: /infinite_canvas_v5/public/icons/reset-view.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M2 10L10 2L18 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M4 10V17C4 17.2761 4.22386 17.5 4.5 17.5H7.5C7.77614 17.5 8 17.2761 8 17V13.5C8 13.2239 8.22386 13 8.5 13H11.5C11.7761 13 12 13.2239 12 13.5V17C12 17.2761 12.2239 17.5 12.5 17.5H15.5C15.7761 17.5 16 17.2761 16 17V10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>


---
File: /infinite_canvas_v5/public/icons/undo.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 7L7 3L7 5.5C11.1421 5.5 14.5 8.85786 14.5 13C14.5 14.3807 14.1193 15.6651 13.4597 16.7743" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M3 7L7 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>


---
File: /infinite_canvas_v5/public/icons/zoom-in.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <circle cx="8.5" cy="8.5" r="5.5" stroke="currentColor" stroke-width="1.5" fill="none"/>
  <path d="m17 17-3.5-3.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <path d="M8.5 6v5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <path d="M6 8.5h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
</svg>


---
File: /infinite_canvas_v5/public/icons/zoom-out.svg
---

<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <circle cx="8.5" cy="8.5" r="5.5" stroke="currentColor" stroke-width="1.5" fill="none"/>
  <path d="m17 17-3.5-3.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <path d="M6 8.5h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
</svg>


---
File: /infinite_canvas_v5/src/AIManager.js
---

// AIManager.js - Handles all AI-related functionality
import { getProviderName, getErrorMessage, generateReplicateImage } from './aiService.js';

export class AIManager {
    constructor(canvasState, uiManager) {
        this.canvasState = canvasState;
        this.uiManager = uiManager;
        
        // AI configuration
        this.apiKey = localStorage.getItem('ai_api_key') || null;
        this.replicateApiKey = localStorage.getItem('replicate_api_key') || null;
        this.baseURL = localStorage.getItem('ai_base_url') || 'https://api.openai.com/v1';
        this.demoMode = localStorage.getItem('ai_demo_mode') !== 'false';
        this.demoModels = 'llama-3.3-70b-versatile,qwen-qwq-32b,gemma2-9b-it';
        this.aiModels = localStorage.getItem('ai_models') || this.demoModels;
        this.activeModels = JSON.parse(localStorage.getItem('ai_active_models') || '{}');
        
        // Image model configuration
        this.defaultImageModels = 'recraft-ai/recraft-v3,google/imagen-4,bytedance/seedream-3';
        this.imageModels = localStorage.getItem('image_models') || this.defaultImageModels;
        this.activeImageModels = JSON.parse(localStorage.getItem('image_active_models') || '{}');
        console.log('Active image models on load:', this.activeImageModels);

        // Ensure demo models are active by default
        this.demoModels.split(',').map(m => m.trim()).forEach(model => {
            if (!(model in this.activeModels)) {
                this.activeModels[model] = true;
            }
        });
        
        // Ensure default image models are active by default
        this.defaultImageModels.split(',').map(m => m.trim()).forEach(model => {
            if (!(model in this.activeImageModels)) {
                this.activeImageModels[model] = true;
            }
        });

        // Note: Generation states are now tracked per-node instead of globally
        // This allows simultaneous AI operations on different nodes
    }
    
    // AI text generation
    async generateAI() {
        if (!this.apiKey && !this.demoMode) {
            this.uiManager.showApiKeyModal();
            return;
        }

        if (this.canvasState.selectedNodes.length === 0) {
            this.uiManager.showNotification('Please select a node first to generate connected ideas', 'warning');
            return;
        }

        if (this.canvasState.selectedNodes.length > 1) {
            this.uiManager.showNotification('Please select only one node to generate ideas. AI generation works with single nodes.', 'warning');
            return;
        }

        const sourceNode = this.canvasState.selectedNode;

        if (sourceNode.isGeneratingAI) {
            this.uiManager.showNotification('AI generation already in progress for this node...', 'info');
            return;
        }

        try {
            sourceNode.isGeneratingAI = true;
            this.uiManager.updateGenerateIdeasTooltip();

            console.log('🎯 Generating ideas for:', sourceNode.text);

            const ancestorNodes = this.canvasState.getAncestorNodes(sourceNode);
            const allModels = this.aiModels.split(',').map(m => m.trim()).filter(m => m.length > 0);
            const models = allModels.filter(model => this.activeModels[model] !== false);

            if (models.length === 0) {
                this.uiManager.showNotification('No active models selected. Please configure your AI models first.', 'warning');
                return;
            }

            this.canvasState.saveState();

            const nodeStillExists = this.canvasState.nodes.find(n => n.id === sourceNode.id);
            if (!nodeStillExists) {
                throw new Error('Source node was deleted during AI generation');
            }

            this.uiManager.showProgressNotification(`Starting AI generation with ${models.length} model(s)...`, models);

            let completedModels = 0;
            let totalNodes = 0;
            const createdNodes = [];

            const onModelComplete = async (modelResult) => {
                completedModels++;

                const sourceStillExists = this.canvasState.nodes.find(n => n.id === sourceNode.id);
                if (!sourceStillExists) {
                    console.warn('⚠️ Source node was deleted during generation, skipping node creation');
                    return;
                }

                if (modelResult.success && modelResult.ideas && modelResult.ideas.length > 0) {
                    modelResult.ideas.forEach((idea) => {
                        const childSpacing = 500;
                        const verticalOffset = 150;
                        const globalIndex = totalNodes;

                        const x = sourceNode.x + (sourceNode.width / 2) - 200 + (globalIndex * childSpacing);
                        const y = sourceNode.y + sourceNode.height + verticalOffset;

                        const newNode = this.canvasState.createNode(idea, x, y, modelResult.model);
                        createdNodes.push(newNode);

                        this.canvasState.createConnection(sourceNode, newNode);
                        totalNodes++;
                    });

                    this.canvasState.saveToLocalStorage();

                    const modelName = modelResult.model.split('/').pop() || modelResult.model;
                    this.uiManager.showNotification(`✅ ${modelName} generated ${modelResult.ideas.length} idea(s)`, 'success', 2000);
                } else if (!modelResult.success) {
                    const modelName = modelResult.model.split('/').pop() || modelResult.model;
                    this.uiManager.showNotification(`❌ ${modelName} failed: ${modelResult.errorMessage}`, 'error', 3000);
                }

                this.uiManager.updateProgressNotification(completedModels, models.length, totalNodes);
            };

            let modelResults;
            if (this.demoMode) {
                const { generateAIIdeasMultipleModelsGroq } = await import('./aiService.js');
                modelResults = await generateAIIdeasMultipleModelsGroq(
                    sourceNode.text,
                    ancestorNodes,
                    models,
                    onModelComplete
                );
            } else {
                const { generateAIIdeasMultipleModels } = await import('./aiService.js');
                modelResults = await generateAIIdeasMultipleModels(
                    this.apiKey,
                    this.baseURL,
                    sourceNode.text,
                    ancestorNodes,
                    models,
                    onModelComplete
                );
            }

            const successfulModels = modelResults.filter(r => r.success).length;
            const failedModels = modelResults.filter(r => !r.success).length;

            let summaryMessage;
            if (totalNodes > 0) {
                summaryMessage = `🎉 Generation complete! Created ${totalNodes} idea(s) from ${successfulModels} model(s)`;
                if (failedModels > 0) {
                    summaryMessage += ` (${failedModels} model(s) failed)`;
                }
            } else {
                summaryMessage = `❌ No ideas generated. All ${models.length} model(s) failed.`;
            }

            this.uiManager.showNotification(summaryMessage, totalNodes > 0 ? 'success' : 'error', 4000);

        } catch (error) {
            console.error('Error calling AI API:', error);
            const errorMessage = getErrorMessage(error);
            this.uiManager.showNotification(errorMessage, 'error');
        } finally {
            sourceNode.isGeneratingAI = false;
            this.uiManager.hideProgressNotification();
            this.uiManager.updateGenerateIdeasTooltip();
        }
    }
    
    // Image generation
    async generateImage() {
        if (this.canvasState.selectedNodes.length !== 1) {
            this.uiManager.showNotification('Please select a single node to generate an image.', 'warning');
            return;
        }
        
        const sourceNode = this.canvasState.selectedNodes[0];
        
        if (!this.replicateApiKey) {
            this.uiManager.showNotification('Please set your Replicate API key in the configuration.', 'error');
            return;
        }
        
        if (sourceNode.isGeneratingImage) {
            this.uiManager.showNotification('Image generation already in progress for this node...', 'info');
            return;
        }

        const allModels = (this.imageModels || '').split(',').map(m => m.trim()).filter(m => m.length > 0);
        const modelsToRun = allModels.filter(model => this.activeImageModels[model] !== false);

        if (modelsToRun.length === 0) {
            this.uiManager.showNotification('No active image models. Please enable models in the ⚙️ configuration menu.', 'warning');
            return;
        }

        try {
            sourceNode.isGeneratingImage = true;
            this.uiManager.updateGenerateIdeasTooltip();
            this.uiManager.showProgressNotification(`Starting image generation with ${modelsToRun.length} model(s)...`, modelsToRun);
            this.canvasState.saveState();

            let completedModels = 0;
            let totalImages = 0;
            const createdNodes = [];
            
            // Get selected aspect ratio from UIManager
            const aspectRatio = this.uiManager.getSelectedAspectRatio();

            const onModelComplete = async (result) => {
                completedModels++;
                
                const sourceStillExists = this.canvasState.nodes.find(n => n.id === sourceNode.id);
                if (!sourceStillExists) {
                    console.warn('⚠️ Source node was deleted during image generation, skipping node creation');
                    return;
                }
                
                if (result.success) {
                    const childSpacing = 450; // width of node (400) + 50 padding
                    const verticalOffset = 150;
                    const globalIndex = totalImages;

                    const x = sourceNode.x + (globalIndex - (modelsToRun.length - 1) / 2) * childSpacing;
                    const y = sourceNode.y + sourceNode.height + verticalOffset;
                    
                    const newNode = this.canvasState.createNode('', x, y, result.model);
                    newNode.width = 320;
                    newNode.height = 240;
                    newNode.isMediaReference = true;
                    newNode.manuallyResized = true;
                    newNode.name = sourceNode.text;
                    newNode.generatedImageUrl = result.imageUrl;
                    createdNodes.push(newNode);
                    
                    this.canvasState.createConnection(sourceNode, newNode);
                    totalImages++;
                    
                    this.canvasState.saveToLocalStorage();
                    const modelName = result.model.split('/').pop() || result.model;
                    this.uiManager.showNotification(`✅ ${modelName} created an image`, 'success', 2000);
                } else {
                    const modelName = result.model.split('/').pop() || result.model;
                    this.uiManager.showNotification(`❌ ${modelName} failed: ${result.errorMessage}`, 'error', 3000);
                }
                
                this.uiManager.updateProgressNotification(completedModels, modelsToRun.length, totalImages);
            };

            const { generateImagesMultipleModels } = await import('./aiService.js');
            const results = await generateImagesMultipleModels(
                sourceNode.text, 
                this.replicateApiKey, 
                modelsToRun, 
                onModelComplete,
                { aspectRatio } // Pass aspect ratio as options
            );

            const successfulCount = results.filter(r => r.success).length;
            if (successfulCount > 0) {
                this.uiManager.showNotification(`🎉 Image generation complete! Created ${successfulCount} new image(s).`, 'success');
                this.canvasState.selectNodes(createdNodes);
            } else {
                this.uiManager.showNotification('❌ All image models failed to generate images.', 'error');
            }

        } catch (err) {
            this.uiManager.showNotification('Image generation failed: ' + err.message, 'error');
        } finally {
            sourceNode.isGeneratingImage = false;
            this.uiManager.hideProgressNotification();
            this.uiManager.updateGenerateIdeasTooltip();
        }
    }
    
    // Image upload
    uploadImage() {
        if (this.canvasState.selectedNodes.length !== 1) {
            this.uiManager.showNotification('Please select a single node to upload an image.', 'warning');
            return;
        }

        const uploadInput = document.getElementById('uploadImageInput');
        uploadInput.click();
    }

    async handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.startsWith('image/')) {
            this.uiManager.showNotification('Please select a valid image file.', 'error');
            return;
        }

        const maxSize = 200 * 1024 * 1024; // 200MB
        if (file.size > maxSize) {
            this.uiManager.showNotification('Image file too large. Please select an image smaller than 200MB.', 'error');
            return;
        }

        const node = this.canvasState.selectedNodes[0];

        try {
            node.isUploadingImage = true;
            this.uiManager.updateGenerateIdeasTooltip();
            this.uiManager.showNotification('Uploading image to cloud...', 'info', 3000);

            const imageUrl = await this.uploadToLitterbox(file);

            node.generatedImageUrl = imageUrl;
            this.canvasState.saveToLocalStorage();

            this.uiManager.showNotification('Image uploaded successfully and is now accessible online!', 'success');
        } catch (err) {
            this.uiManager.showNotification('Image upload failed: ' + err.message, 'error');
        } finally {
            node.isUploadingImage = false;
            this.uiManager.updateGenerateIdeasTooltip();
            event.target.value = '';
        }
    }

    async uploadToLitterbox(file) {
        return new Promise((resolve, reject) => {
            const formData = new FormData();
            formData.append('reqtype', 'fileupload');
            formData.append('time', '72h');
            formData.append('fileToUpload', file);

            const xhr = new XMLHttpRequest();
            
            xhr.onload = function() {
                if (xhr.status === 200) {
                    const response = xhr.responseText.trim();
                    if (response.startsWith('https://')) {
                        resolve(response);
                    } else {
                        reject(new Error('Invalid response from upload service: ' + response));
                    }
                } else {
                    reject(new Error(`Upload failed with status ${xhr.status}: ${xhr.statusText}`));
                }
            };

            xhr.onerror = function() {
                reject(new Error('Network error during upload'));
            };

            xhr.ontimeout = function() {
                reject(new Error('Upload timed out'));
            };

            xhr.timeout = 60000;
            xhr.open('POST', 'https://litterbox.catbox.moe/resources/internals/api.php');
            xhr.send(formData);
        });
    }
    
    // Context image editing
    contextImage() {
        if (this.canvasState.selectedNodes.length !== 1) {
            this.uiManager.showNotification('Please select a single node to edit an image.', 'warning');
            return;
        }

        const node = this.canvasState.selectedNodes[0];

        if (!this.replicateApiKey) {
            this.uiManager.showNotification('Please set your Replicate API key in the configuration.', 'error');
            return;
        }

        if (!node.text || node.text.trim() === '' || node.text.trim() === 'New Node') {
            this.uiManager.showNotification('Please add text content to this node to use as editing instructions.', 'warning');
            return;
        }

        if (node.isGeneratingContext) {
            this.uiManager.showNotification('Image editing already in progress for this node...', 'info');
            return;
        }

        // Find connected image node
        const connectedImageNode = this.findConnectedImageNode(node);
        
        if (connectedImageNode) {
            this.generateContextImageFromConnected(node, connectedImageNode);
        } else {
            this.generateImageThenEdit(node);
        }
    }

    findConnectedImageNode(textNode) {
        const connections = this.canvasState.connections;
        const connectedNodeIds = new Set();
        
        // Find all nodes connected to this text node
        connections.forEach(conn => {
            if (conn.from === textNode.id) {
                connectedNodeIds.add(conn.to);
            }
            if (conn.to === textNode.id) {
                connectedNodeIds.add(conn.from);
            }
        });
        
        // Find the first connected image node
        return this.canvasState.nodes.find(node => 
            connectedNodeIds.has(node.id) && 
            node.isMediaReference && 
            node.generatedImageUrl
        );
    }

    async generateContextImageFromConnected(textNode, imageNode) {
        try {
            textNode.isGeneratingContext = true;
            this.uiManager.updateGenerateIdeasTooltip();
            this.uiManager.showNotification('Editing connected image with AI...', 'info', 3000);

            const editedImageUrl = await this.generateReplicateContextImage(
                imageNode.generatedImageUrl, 
                textNode.text, 
                this.replicateApiKey
            );

            // Create new image node with edited image
            const newNodeX = textNode.x + textNode.width + 50;
            const newNodeY = textNode.y;
            
            const newNode = this.canvasState.createNode('', newNodeX, newNodeY);
            newNode.width = 320;
            newNode.height = 240;
            newNode.isMediaReference = true;
            newNode.manuallyResized = true;
            newNode.name = textNode.text;
            newNode.generatedImageUrl = editedImageUrl;
            
            this.canvasState.createConnection(textNode, newNode);
            this.canvasState.selectNodes(newNode);
            this.canvasState.saveToLocalStorage();

            this.uiManager.showNotification('Connected image edited successfully! Created new image node.', 'success');
        } catch (err) {
            this.uiManager.showNotification('Image editing failed: ' + err.message, 'error');
        } finally {
            textNode.isGeneratingContext = false;
            this.uiManager.updateGenerateIdeasTooltip();
        }
    }

    async generateImageThenEdit(node) {
        try {
            node.isGeneratingContext = true;
            this.uiManager.updateGenerateIdeasTooltip();
            this.uiManager.showNotification('Generating image and then editing it...', 'info', 5000);

            // First generate an image from the text
            const imageUrl = await this.generateReplicateImage(node.text, this.replicateApiKey);
            
            // Create initial image node
            const imageNodeX = node.x + node.width + 50;
            const imageNodeY = node.y;
            
            const imageNode = this.canvasState.createNode('', imageNodeX, imageNodeY);
            imageNode.width = 320;
            imageNode.height = 240;
            imageNode.isMediaReference = true;
            imageNode.manuallyResized = true;
            imageNode.name = node.text;
            imageNode.generatedImageUrl = imageUrl;
            
            this.canvasState.createConnection(node, imageNode);
            this.canvasState.saveToLocalStorage();

            // Now edit the generated image with the same text as instructions
            const editedImageUrl = await this.generateReplicateContextImage(
                imageUrl, 
                node.text, 
                this.replicateApiKey
            );

            // Create edited image node
            const editedNodeX = imageNodeX + 320 + 50;
            const editedNodeY = imageNodeY;
            
            const editedNode = this.canvasState.createNode('', editedNodeX, editedNodeY);
            editedNode.width = 320;
            editedNode.height = 240;
            editedNode.isMediaReference = true;
            editedNode.manuallyResized = true;
            editedNode.name = node.text;
            editedNode.generatedImageUrl = editedImageUrl;
            
            this.canvasState.createConnection(imageNode, editedNode);
            this.canvasState.selectNodes(editedNode);
            this.canvasState.saveToLocalStorage();

            this.uiManager.showNotification('Image generated and edited successfully!', 'success');
        } catch (err) {
            this.uiManager.showNotification('Image generation and editing failed: ' + err.message, 'error');
        } finally {
            node.isGeneratingContext = false;
            this.uiManager.updateGenerateIdeasTooltip();
        }
    }

    async generateReplicateImage(prompt, replicateApiKey) {
        const { generateReplicateImage } = await import('./aiService.js');
        return await generateReplicateImage(prompt, replicateApiKey);
    }

    async generateReplicateContextImage(imageUrl, prompt, replicateApiKey) {
        if (!replicateApiKey || !replicateApiKey.startsWith('r8_')) {
            throw new Error('Valid Replicate API key required.');
        }

        const submitRes = await fetch('/api/replicate-context', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                imageUrl, 
                prompt, 
                replicateApiKey,
                aspectRatio: 'match_input_image' // Use match_input_image for FLUX Kontext
            })
        });

        if (!submitRes.ok) {
            const err = await submitRes.text();
            throw new Error('Replicate context proxy error: ' + err);
        }

        const submitData = await submitRes.json();
        const getUrl = submitData.urls.get;

        let status = submitData.status;
        let outputUrl = null;
        let pollCount = 0;

        while (status !== 'succeeded' && status !== 'failed' && pollCount < 60) {
            await new Promise(r => setTimeout(r, 3000));
            
            const pollRes = await fetch('/api/replicate-poll', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ getUrl, replicateApiKey })
            });

            if (!pollRes.ok) {
                throw new Error('Polling error: ' + (await pollRes.text()));
            }

            const pollData = await pollRes.json();
            status = pollData.status;

            if (status === 'succeeded') {
                outputUrl = Array.isArray(pollData.output) ? pollData.output[0] : pollData.output;
            } else if (status === 'failed') {
                throw new Error('Image editing failed: ' + (pollData.error || 'Unknown error'));
            }

            pollCount++;
        }

        if (!outputUrl) {
            throw new Error('Image editing timed out or failed.');
        }

        return outputUrl;
    }
    
    // Video generation
    async generateVideo() {
        if (this.canvasState.selectedNodes.length !== 1) {
            this.uiManager.showNotification('Please select a single node to generate a video.', 'warning');
            return;
        }

        const node = this.canvasState.selectedNodes[0];

        if (!this.replicateApiKey) {
            this.uiManager.showNotification('Please set your Replicate API key in the configuration.', 'error');
            return;
        }

        if (!node.text || node.text.trim() === '' || node.text.trim() === 'New Node') {
            this.uiManager.showNotification('Please add text content to this node to use as video prompt.', 'warning');
            return;
        }

        if (node.isGeneratingVideo) {
            this.uiManager.showNotification('Video generation already in progress for this node...', 'info');
            return;
        }

        try {
            node.isGeneratingVideo = true;
            this.uiManager.updateGenerateIdeasTooltip();

            // Check for connected image nodes
            const connectedImageNode = this.findConnectedImageNode(node);
            const hasImage = connectedImageNode && connectedImageNode.generatedImageUrl;
            const modeText = hasImage ? 'image-to-video' : 'text-to-video';
            
            this.uiManager.showNotification(`Generating ${modeText} with AI...`, 'info', 3000);

            const videoUrl = await this.generateReplicateVideo(
                node.text,
                hasImage ? connectedImageNode.generatedImageUrl : null,
                this.replicateApiKey
            );

            // Create new video node instead of embedding in text node
            const newNodeX = node.x + node.width + 50;
            const newNodeY = node.y;
            
            const videoNode = this.canvasState.createNode('', newNodeX, newNodeY);
            videoNode.width = 480;
            videoNode.height = 320; // 270 (16:9 video) + 50 (header) = 320 total
            videoNode.isMediaReference = true;
            videoNode.manuallyResized = true;
            videoNode.name = node.text;
            videoNode.generatedVideoUrl = videoUrl;
            videoNode._headerHeight = 50; // Add header height for consistent UI with image nodes
            
            this.canvasState.createConnection(node, videoNode);
            this.canvasState.selectNodes(videoNode);
            this.canvasState.saveToLocalStorage();

            this.uiManager.showNotification(`Video generated successfully using ${modeText}!`, 'success');
        } catch (err) {
            this.uiManager.showNotification('Video generation failed: ' + err.message, 'error');
        } finally {
            node.isGeneratingVideo = false;
            this.uiManager.updateGenerateIdeasTooltip();
        }
    }

    async generateReplicateVideo(prompt, imageUrl, replicateApiKey) {
        if (!replicateApiKey || !replicateApiKey.startsWith('r8_')) {
            throw new Error('Valid Replicate API key required.');
        }

        const submitRes = await fetch('/api/replicate-video', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                prompt, 
                imageUrl,
                replicateApiKey 
            })
        });

        if (!submitRes.ok) {
            const err = await submitRes.text();
            throw new Error('Replicate video proxy error: ' + err);
        }

        const submitData = await submitRes.json();
        const getUrl = submitData.urls.get;

        let status = submitData.status;
        let outputUrl = null;
        let pollCount = 0;

        while (status !== 'succeeded' && status !== 'failed' && pollCount < 120) {
            await new Promise(r => setTimeout(r, 5000));
            
            const pollRes = await fetch('/api/replicate-poll', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ getUrl, replicateApiKey })
            });

            if (!pollRes.ok) {
                throw new Error('Polling error: ' + (await pollRes.text()));
            }

            const pollData = await pollRes.json();
            status = pollData.status;

            if (status === 'succeeded') {
                outputUrl = Array.isArray(pollData.output) ? pollData.output[0] : pollData.output;
            } else if (status === 'failed') {
                throw new Error('Video generation failed: ' + (pollData.error || 'Unknown error'));
            }

            pollCount++;
        }

        if (!outputUrl) {
            throw new Error('Video generation timed out or failed.');
        }

        return outputUrl;
    }
    
    // Configuration management
    saveApiConfig(apiKey, replicateApiKey, baseURL, aiModels, activeModels, demoMode, imageModels, activeImageModels) {
        this.apiKey = apiKey;
        this.replicateApiKey = replicateApiKey;
        this.baseURL = baseURL;
        this.aiModels = aiModels;
        this.activeModels = activeModels;
        this.demoMode = demoMode;
        this.imageModels = imageModels;
        this.activeImageModels = activeImageModels;
        
        if (demoMode) {
            localStorage.removeItem('ai_api_key');
            localStorage.removeItem('ai_base_url');
            localStorage.setItem('ai_models', this.demoModels);
            // We still save active models for demo mode
            localStorage.setItem('ai_active_models', JSON.stringify(this.activeModels));
        } else {
            localStorage.setItem('ai_api_key', apiKey);
            localStorage.setItem('ai_base_url', baseURL);
            localStorage.setItem('ai_models', aiModels);
            localStorage.setItem('ai_active_models', JSON.stringify(activeModels));
        }
        
        if (replicateApiKey) {
            localStorage.setItem('replicate_api_key', replicateApiKey);
        }
        
        localStorage.setItem('image_models', imageModels);
        localStorage.setItem('image_active_models', JSON.stringify(activeImageModels));
        localStorage.setItem('ai_demo_mode', demoMode.toString());

        this.uiManager.updateModelSelectorUI();
        if (this.uiManager.updateImageModelSelectorUI) {
            this.uiManager.updateImageModelSelectorUI();
        }
        this.uiManager.updateApiConfigButton();

        const provider = this.getProviderName();
        this.uiManager.showNotification(`Configuration saved successfully for ${provider}`, 'success');
    }
    
    getProviderName() {
        if (this.demoMode) return 'Demo Mode (Groq)';
        return getProviderName(this.baseURL);
    }

    // Generate with reference images using RunwayML Gen-4
    async generateWithReference() {
        if (this.canvasState.selectedNodes.length !== 1) {
            this.uiManager.showNotification('Please select a single text node to generate with references.', 'warning');
            return;
        }
        
        const textNode = this.canvasState.selectedNodes[0];
        
        if (!this.replicateApiKey) {
            this.uiManager.showNotification('Please set your Replicate API key in the configuration.', 'error');
            return;
        }
        
        if (!textNode.text || textNode.text.trim() === '' || textNode.text.trim() === 'New Node') {
            this.uiManager.showNotification('Please add text content to this node to use as generation prompt.', 'warning');
            return;
        }
        
        if (textNode.isGeneratingReference) {
            this.uiManager.showNotification('Reference generation already in progress for this node...', 'info');
            return;
        }
        
        // Find all connected image nodes
        const connectedImageNodes = this.findConnectedImageNodes(textNode);
        
        if (connectedImageNodes.length === 0) {
            this.uiManager.showNotification('No connected image nodes found. Connect some image nodes to use as references.', 'warning');
            return;
        }
        
        if (connectedImageNodes.length > 3) {
            this.uiManager.showNotification('Too many connected images. Gen-4 supports up to 3 reference images. Using the first 3.', 'warning');
        }
        
        try {
            textNode.isGeneratingReference = true;
            this.uiManager.updateGenerateIdeasTooltip();
            
            const referenceCount = Math.min(connectedImageNodes.length, 3);
            this.uiManager.showNotification(`Generating image with ${referenceCount} reference(s) using RunwayML Gen-4...`, 'info', 5000);
            
            const referenceImages = connectedImageNodes.slice(0, 3).map(node => node.generatedImageUrl);
            const referenceTags = connectedImageNodes.slice(0, 3).map(node => {
                // Generate valid tag from node name or create default
                const baseName = (node.name && node.name.trim()) ? node.name.trim() : `ref${Math.floor(Math.random() * 1000)}`;
                // Make tag alphanumeric and 3-15 characters
                let tag = baseName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                if (tag.length < 3) tag = tag + 'ref';
                if (tag.length > 15) tag = tag.substring(0, 15);
                if (!/^[a-zA-Z]/.test(tag)) tag = 'ref' + tag.substring(0, 12);
                return tag;
            });
            
            // Get selected aspect ratio from UIManager
            const aspectRatio = this.uiManager.getSelectedAspectRatio();
            
            const imageUrl = await this.generateRunwayGen4Image(
                textNode.text,
                referenceImages,
                referenceTags,
                this.replicateApiKey,
                aspectRatio // Pass aspect ratio
            );
            
            // Create new image node with generated result
            const newNodeX = textNode.x + textNode.width + 50;
            const newNodeY = textNode.y;
            
            const newNode = this.canvasState.createNode('', newNodeX, newNodeY);
            newNode.width = 320;
            newNode.height = 240;
            newNode.isMediaReference = true;
            newNode.manuallyResized = true;
            newNode.name = textNode.text;
            newNode.generatedImageUrl = imageUrl;
            
            this.canvasState.createConnection(textNode, newNode);
            this.canvasState.selectNodes(newNode);
            this.canvasState.saveToLocalStorage();
            
            this.uiManager.showNotification(`Image generated successfully with ${referenceCount} reference(s)!`, 'success');
        } catch (err) {
            this.uiManager.showNotification('Reference generation failed: ' + err.message, 'error');
        } finally {
            textNode.isGeneratingReference = false;
            this.uiManager.updateGenerateIdeasTooltip();
        }
    }
    
    findConnectedImageNodes(textNode) {
        const connections = this.canvasState.connections;
        const inputImageNodeIds = new Set();
        
        // Find only image nodes that are inputs to this text node
        // (connections FROM image nodes TO this text node)
        connections.forEach(conn => {
            if (conn.to === textNode.id) {
                inputImageNodeIds.add(conn.from);
            }
        });
        
        // Return only input image nodes (not output/generated ones)
        return this.canvasState.nodes.filter(node => 
            inputImageNodeIds.has(node.id) && 
            node.isMediaReference && 
            node.generatedImageUrl
        );
    }
    
    async generateRunwayGen4Image(prompt, referenceImages, referenceTags, replicateApiKey, aspectRatio) {
        if (!replicateApiKey || !replicateApiKey.startsWith('r8_')) {
            throw new Error('Valid Replicate API key required.');
        }
        
        const submitRes = await fetch('/api/replicate-gen4', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                prompt,
                referenceImages,
                referenceTags,
                replicateApiKey,
                aspectRatio
            })
        });
        
        if (!submitRes.ok) {
            const err = await submitRes.text();
            throw new Error('RunwayML Gen-4 proxy error: ' + err);
        }
        
        const submitData = await submitRes.json();
        const getUrl = submitData.urls.get;
        
        let status = submitData.status;
        let outputUrl = null;
        let pollCount = 0;
        
        while (status !== 'succeeded' && status !== 'failed' && pollCount < 60) {
            await new Promise(r => setTimeout(r, 5000));
            
            const pollRes = await fetch('/api/replicate-poll', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ getUrl, replicateApiKey })
            });
            
            if (!pollRes.ok) {
                throw new Error('Polling error: ' + (await pollRes.text()));
            }
            
            const pollData = await pollRes.json();
            status = pollData.status;
            
            if (status === 'succeeded') {
                outputUrl = Array.isArray(pollData.output) ? pollData.output[0] : pollData.output;
            } else if (status === 'failed') {
                throw new Error('Gen-4 generation failed: ' + (pollData.error || 'Unknown error'));
            }
            
            pollCount++;
        }
        
        if (!outputUrl) {
            throw new Error('Gen-4 generation timed out or failed.');
        }
        
        return outputUrl;
    }
} 


---
File: /infinite_canvas_v5/src/aiService.js
---

// AI Service Module
// Handles all AI API interactions and provider-specific logic

import OpenAI from 'openai';

export function getProviderName(baseURL) {
    if (!baseURL) return 'Demo Mode (Groq)';
    if (baseURL.includes('openrouter.ai')) return 'OpenRouter';
    if (baseURL.includes('api.openai.com')) return 'OpenAI';
    if (baseURL.includes('api.groq.com')) return 'Groq';
    if (baseURL.includes('localhost') || baseURL.includes('127.0.0.1')) return 'Local API';
    return 'Custom API';
}

export async function generateAIIdeas(apiKey, baseURL, selectedNodeText, connectedNodes = [], model = null) {
    // Validate inputs
    if (!apiKey || apiKey.trim() === '') {
        throw new Error('API key is required');
    }

    if (!baseURL || baseURL.trim() === '') {
        throw new Error('Base URL is required');
    }

    // Check for common API key/provider mismatches
    if (baseURL.includes('openrouter.ai') && apiKey.startsWith('sk-proj-')) {
        throw new Error('You are using an OpenAI API key with OpenRouter. Please either:\n1. Change Base URL to: https://api.openai.com/v1\n2. Or get an OpenRouter API key from openrouter.ai');
    }

    if (baseURL.includes('api.openai.com') && apiKey.startsWith('sk-or-')) {
        throw new Error('You are using an OpenRouter API key with OpenAI. Please either:\n1. Change Base URL to: https://openrouter.ai/api/v1\n2. Or use your OpenAI API key instead');
    }

    // Use provided model or determine the appropriate model based on provider
    let finalModel = model;
    if (!finalModel) {
        finalModel = "gpt-3.5-turbo"; // Default for OpenAI
        if (baseURL.includes('openrouter.ai')) {
            finalModel = "openai/gpt-4o-mini"; // Use a reliable OpenRouter model
        }
    }

    let extraHeaders = {};
    if (baseURL.includes('openrouter.ai')) {
        extraHeaders = {
            "HTTP-Referer": window.location.origin,
            "X-Title": "Infinite Canvas AI"
        };
    }



    // Create OpenAI client
    const openaiClient = new OpenAI({
        apiKey: apiKey,
        baseURL: baseURL,
        dangerouslyAllowBrowser: true,
        defaultHeaders: extraHeaders
    });

    // Construct messages array with connected nodes as conversation history
    let messages = [];

    if (connectedNodes && connectedNodes.length > 0) {
        // Add connected nodes as previous messages in the conversation
        connectedNodes.forEach(node => {
            messages.push({ role: "user", content: node.text });
        });
        console.log('📎 Using', connectedNodes.length, 'connected nodes as conversation history');
    } else {
        console.log('📝 No connected nodes, starting new conversation');
    }

    // Add the current selected node as the latest message
    messages.push({ role: "user", content: selectedNodeText });

    console.log('🤖 AI Call - Model:', finalModel, 'Provider:', getProviderName(baseURL));
    console.log('💬 Message history:', messages.map(m => m.content));

    // Call AI API
    try {

        const completion = await openaiClient.chat.completions.create({
            model: finalModel,
            messages: messages,
            temperature: 0.7
        });

        const responseText = completion.choices[0].message.content;
        console.log('✅ AI response:', responseText);

        // Return the AI response as a single idea (one node)
        const trimmedResponse = responseText.trim();

        if (!trimmedResponse) {
            throw new Error('AI generated empty response');
        }

        return [trimmedResponse]; // Always return as array with single item
    } catch (apiError) {
        console.error('❌ AI API Error:', apiError.message);

        // Re-throw the error to be handled by the calling function
        throw apiError;
    }
}

export function getErrorMessage(error) {
    let errorMessage = 'Failed to generate AI ideas. ';

    // Check for specific error patterns
    const errorString = error.message || JSON.stringify(error) || '';

    if (errorString.includes('No auth credentials found') || errorString.includes('401')) {
        errorMessage += 'Authentication failed. Please check your API key and make sure it\'s valid for the selected provider.';
    } else if (errorString.includes('API key')) {
        errorMessage += 'Please check your API key.';
    } else if (errorString.includes('quota') || errorString.includes('insufficient_quota')) {
        errorMessage += 'API quota exceeded.';
    } else if (errorString.includes('network') || errorString.includes('fetch')) {
        errorMessage += 'Network error. Please try again.';
    } else if (errorString.includes('unauthorized')) {
        errorMessage += 'Invalid API key or unauthorized access.';
    } else if (errorString.includes('429') || errorString.includes('rate limit')) {
        errorMessage += 'Rate limit exceeded. Please wait and try again.';
    } else if (errorString.includes('model') && errorString.includes('not found')) {
        errorMessage += 'The requested model is not available. Please try a different model.';
    } else {
        errorMessage += errorString || 'Unknown error occurred.';
    }

    return errorMessage;
}

export async function generateAIIdeasMultipleModels(apiKey, baseURL, selectedNodeText, connectedNodes = [], models = [], onModelComplete = null) {
    if (!models || models.length === 0) {
        throw new Error('No models specified');
    }

    const trimmedModels = models.map(m => m.trim()).filter(m => m.length > 0);

    if (trimmedModels.length === 0) {
        throw new Error('No valid models specified');
    }

    console.log(`🚀 Starting parallel generation with ${trimmedModels.length} models:`, trimmedModels);

    // Create promises for all models to run in parallel
    const modelPromises = trimmedModels.map(async (model) => {
        try {
            console.log(`🤖 Starting generation with model: ${model}`);
            const ideas = await generateAIIdeas(apiKey, baseURL, selectedNodeText, connectedNodes, model);

            const result = {
                model: model,
                ideas: ideas,
                success: true,
                timestamp: Date.now()
            };

            // Call the callback immediately when this model completes
            if (onModelComplete && typeof onModelComplete === 'function') {
                try {
                    await onModelComplete(result);
                } catch (callbackError) {
                    console.error(`❌ Error in onModelComplete callback for ${model}:`, callbackError);
                }
            }

            console.log(`✅ Completed generation with model: ${model}`);
            return result;
        } catch (error) {
            console.error(`❌ Error with model ${model}:`, error.message);

            const result = {
                model: model,
                ideas: [`Error with ${model}: ${error.message}`],
                success: false,
                error: true,
                errorMessage: error.message,
                timestamp: Date.now()
            };

            // Call the callback even for errors
            if (onModelComplete && typeof onModelComplete === 'function') {
                try {
                    await onModelComplete(result);
                } catch (callbackError) {
                    console.error(`❌ Error in onModelComplete callback for ${model}:`, callbackError);
                }
            }

            return result;
        }
    });

    // Wait for all models to complete (or fail)
    const results = await Promise.allSettled(modelPromises);

    // Extract the actual results from Promise.allSettled
    const finalResults = results.map(result => {
        if (result.status === 'fulfilled') {
            return result.value;
        } else {
            // This should rarely happen since we handle errors inside the promise
            console.error('❌ Unexpected promise rejection:', result.reason);
            return {
                model: 'unknown',
                ideas: [`Unexpected error: ${result.reason?.message || 'Unknown error'}`],
                success: false,
                error: true,
                errorMessage: result.reason?.message || 'Unknown error',
                timestamp: Date.now()
            };
        }
    });

    const successCount = finalResults.filter(r => r.success).length;
    const errorCount = finalResults.filter(r => !r.success).length;

    console.log(`🏁 Parallel generation completed: ${successCount} successful, ${errorCount} failed`);

    return finalResults;
}

// ============================================================================
// GROQ API FUNCTIONS (Demo Mode - Free, Ultra-Fast Inference)
// ============================================================================

// Demo Groq API key from environment variables (secure)
let DEMO_GROQ_API_KEY = import.meta.env.VITE_GROQ_API_KEY;

// Handle case where environment variable includes the variable name (common Vercel mistake)
if (DEMO_GROQ_API_KEY && DEMO_GROQ_API_KEY.includes('VITE_GROQ_API_KEY=')) {
    DEMO_GROQ_API_KEY = DEMO_GROQ_API_KEY.split('VITE_GROQ_API_KEY=')[1];
    console.log('🔧 Fixed environment variable parsing');
}

// Debug environment variables in production
console.log('🔍 Environment Debug:');
console.log('- Raw env var:', import.meta.env.VITE_GROQ_API_KEY ? 'SET' : 'NOT SET');
console.log('- Parsed API key:', DEMO_GROQ_API_KEY ? `${DEMO_GROQ_API_KEY.substring(0, 10)}...` : 'NOT SET');
console.log('- import.meta.env.MODE:', import.meta.env.MODE);
console.log('- import.meta.env.PROD:', import.meta.env.PROD);

export async function generateAIIdeasGroq(selectedNodeText, connectedNodes = [], model = 'llama-3.3-70b-versatile') {
    console.log('🎯 Using Groq Demo Mode');
    console.log('🤖 Model:', model);

    // Check if API key is available from environment
    if (!DEMO_GROQ_API_KEY) {
        console.error('❌ Groq API key not found in environment variables');
        console.error('- VITE_GROQ_API_KEY:', import.meta.env.VITE_GROQ_API_KEY ? 'SET' : 'NOT SET');
        throw new Error('Groq API key not found. Please check your environment variables in Vercel dashboard.');
    }

    // Demo API key is now configured, proceed with Groq API

    // Construct messages array with connected nodes as conversation history
    let messages = [];

    if (connectedNodes && connectedNodes.length > 0) {
        // Add connected nodes as previous messages in the conversation
        connectedNodes.forEach(node => {
            messages.push({ role: "user", content: node.text });
        });
        console.log('📎 Using', connectedNodes.length, 'connected nodes as conversation history');
    }

    // Add the current selected node as the latest message
    messages.push({ role: "user", content: selectedNodeText });

    console.log('💬 Message history:', messages.map(m => m.content));

    try {
        // Create OpenAI client configured for Groq
        const groqClient = new OpenAI({
            apiKey: DEMO_GROQ_API_KEY,
            baseURL: 'https://api.groq.com/openai/v1',
            dangerouslyAllowBrowser: true
        });

        console.log('🚀 Calling Groq API...');

        const completion = await groqClient.chat.completions.create({
            model: model,
            messages: messages,
            temperature: 0.7,
            max_tokens: 150
        });

        const responseText = completion.choices[0].message.content;
        console.log('✅ Groq response:', responseText);

        // Return the AI response as a single idea (one node)
        const trimmedResponse = responseText.trim();

        if (!trimmedResponse) {
            throw new Error('Groq generated empty response');
        }

        return [trimmedResponse]; // Always return as array with single item

    } catch (apiError) {
        console.error('❌ Groq API Error:', apiError.message);

        // Fallback to mock response if API fails
        console.log('🔄 Falling back to mock response...');
        return generateMockResponse(selectedNodeText, model);
    }
}

// Fallback function for when Groq API is not available
function generateMockResponse(selectedNodeText, model) {
    const modelName = model.toLowerCase();
    const input = selectedNodeText.toLowerCase();

    // Generate contextual mock responses
    let responses = [];

    if (modelName.includes('llama')) {
        responses = [
            `Building on "${selectedNodeText.substring(0, 30)}...", here's an expanded perspective from Llama 3.3.`,
            `Your idea about "${selectedNodeText.substring(0, 25)}..." could be developed further with advanced reasoning.`,
            `Considering "${selectedNodeText.substring(0, 20)}...", what about exploring related concepts with deeper analysis?`
        ];
    } else if (modelName.includes('mixtral')) {
        responses = [
            `From multiple angles: "${selectedNodeText.substring(0, 30)}..." presents interesting opportunities.`,
            `Analyzing "${selectedNodeText.substring(0, 25)}..." from different perspectives reveals new insights.`,
            `Your concept "${selectedNodeText.substring(0, 20)}..." could benefit from diverse viewpoints.`
        ];
    } else if (modelName.includes('gemma')) {
        responses = [
            `Thoughtfully considering "${selectedNodeText.substring(0, 30)}...", here are some insights.`,
            `Reflecting on "${selectedNodeText.substring(0, 25)}...", this could lead to interesting developments.`,
            `Your idea "${selectedNodeText.substring(0, 20)}..." has potential for creative expansion.`
        ];
    }

    // Add topic-specific responses
    if (input.includes('business') || input.includes('startup')) {
        responses.push('Consider market validation and competitive analysis for this business concept.');
    } else if (input.includes('technology') || input.includes('software')) {
        responses.push('Technical implementation and scalability are key factors to consider.');
    } else if (input.includes('creative') || input.includes('art')) {
        responses.push('Explore different artistic mediums and creative approaches for this idea.');
    } else {
        responses.push('This concept has potential for further development and exploration.');
    }

    const responseText = responses[Math.floor(Math.random() * responses.length)];
    console.log('✅ Mock response generated:', responseText);
    return [responseText];
}

export async function generateAIIdeasMultipleModelsGroq(selectedNodeText, connectedNodes = [], models = [], onModelComplete = null) {
    if (!models || models.length === 0) {
        throw new Error('No models specified');
    }

    const trimmedModels = models.map(m => m.trim()).filter(m => m.length > 0);

    if (trimmedModels.length === 0) {
        throw new Error('No valid models specified');
    }

    console.log(`🚀 Starting parallel Groq generation with ${trimmedModels.length} models:`, trimmedModels);

    // Create promises for all models to run in parallel
    const modelPromises = trimmedModels.map(async (model) => {
        try {
            console.log(`🤖 Starting Groq generation with model: ${model}`);
            const ideas = await generateAIIdeasGroq(selectedNodeText, connectedNodes, model);

            const result = {
                model: model,
                ideas: ideas,
                success: true,
                timestamp: Date.now()
            };

            // Call the callback immediately when this model completes
            if (onModelComplete && typeof onModelComplete === 'function') {
                try {
                    await onModelComplete(result);
                } catch (callbackError) {
                    console.error(`❌ Error in onModelComplete callback for ${model}:`, callbackError);
                }
            }

            console.log(`✅ Completed Groq generation with model: ${model}`);
            return result;
        } catch (error) {
            console.error(`❌ Error with Groq model ${model}:`, error.message);

            const result = {
                model: model,
                ideas: [`Groq demo error with ${model}: ${error.message}`],
                success: false,
                error: true,
                errorMessage: error.message,
                timestamp: Date.now()
            };

            // Call the callback even for errors
            if (onModelComplete && typeof onModelComplete === 'function') {
                try {
                    await onModelComplete(result);
                } catch (callbackError) {
                    console.error(`❌ Error in onModelComplete callback for ${model}:`, callbackError);
                }
            }

            return result;
        }
    });

    // Wait for all models to complete (or fail)
    const results = await Promise.allSettled(modelPromises);

    // Extract the actual results from Promise.allSettled
    const finalResults = results.map(result => {
        if (result.status === 'fulfilled') {
            return result.value;
        } else {
            // This should rarely happen since we handle errors inside the promise
            console.error('❌ Unexpected promise rejection:', result.reason);
            return {
                model: 'unknown',
                ideas: [`Unexpected Groq demo error: ${result.reason?.message || 'Unknown error'}`],
                success: false,
                error: true,
                errorMessage: result.reason?.message || 'Unknown error',
                timestamp: Date.now()
            };
        }
    });

    const successCount = finalResults.filter(r => r.success).length;
    const errorCount = finalResults.filter(r => !r.success).length;

    console.log(`🏁 Parallel Groq generation completed: ${successCount} successful, ${errorCount} failed`);

    return finalResults;
}

/**
 * Generate an image using Replicate API (text-to-image)
 * @param {string} prompt - The prompt for image generation
 * @param {string} replicateApiKey - The user's Replicate API key
 * @param {object} options - Optional parameters (model, aspect_ratio, etc.)
 * @returns {Promise<string>} - Resolves to the image URL
 */
export async function generateReplicateImage(prompt, replicateApiKey, options = {}) {
    if (!replicateApiKey || !replicateApiKey.startsWith('r8_')) {
        throw new Error('Valid Replicate API key required.');
    }

    const { model = 'bytedance/seedream-3', aspectRatio = '1:1' } = options;

    // Use the proxy server for Replicate API calls to protect the API key
    const submitRes = await fetch('/api/replicate-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            prompt, 
            replicateApiKey,
            model, // Pass model to proxy
            aspectRatio // Pass aspect ratio to proxy
        })
    });

    if (!submitRes.ok) {
        const err = await submitRes.text();
        throw new Error('Replicate proxy error: ' + err);
    }
    const submitData = await submitRes.json();
    const getUrl = submitData.urls.get;
    // 2. Poll for result (now via proxy)
    let status = submitData.status;
    let outputUrl = null;
    let pollCount = 0;
    while (status !== 'succeeded' && status !== 'failed' && pollCount < 40) {
        await new Promise(r => setTimeout(r, 2500));
        const pollRes = await fetch('/api/replicate-poll', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ getUrl, replicateApiKey })
        });
        if (!pollRes.ok) {
            throw new Error('Polling error: ' + (await pollRes.text()));
        }
        const pollData = await pollRes.json();
        status = pollData.status;
        if (status === 'succeeded') {
            outputUrl = Array.isArray(pollData.output) ? pollData.output[0] : pollData.output;
        } else if (status === 'failed') {
            throw new Error('Image generation failed: ' + (pollData.error || 'Unknown error'));
        }
        pollCount++;
    }
    if (!outputUrl) throw new Error('Image generation timed out or failed.');
    return outputUrl;
}

export async function generateImagesMultipleModels(prompt, replicateApiKey, models = [], onModelComplete = null, options = {}) {
    if (!models || models.length === 0) {
        throw new Error('No image models specified');
    }

    const { aspectRatio = '1:1' } = options;

    console.log(`🚀 Starting parallel image generation with ${models.length} models:`, models);

    const modelPromises = models.map(async (model) => {
        try {
            console.log(`🖼️ Starting image generation with model: ${model}`);
            const imageUrl = await generateReplicateImage(prompt, replicateApiKey, { 
                model, 
                aspectRatio 
            });

            const result = {
                model: model,
                imageUrl: imageUrl,
                success: true,
                timestamp: Date.now()
            };

            if (onModelComplete) {
                try {
                    await onModelComplete(result);
                } catch (callbackError) {
                    console.error(`❌ Error in onModelComplete callback for ${model}:`, callbackError);
                }
            }

            console.log(`✅ Completed image generation with model: ${model}`);
            return result;
        } catch (error) {
            console.error(`❌ Error with image model ${model}:`, error.message);

            const result = {
                model: model,
                imageUrl: null,
                success: false,
                errorMessage: error.message,
                timestamp: Date.now()
            };

            if (onModelComplete) {
                try {
                    await onModelComplete(result);
                } catch (callbackError) {
                    console.error(`❌ Error in onModelComplete callback for ${model}:`, callbackError);
                }
            }
            return result;
        }
    });

    const results = await Promise.allSettled(modelPromises);
    const finalResults = results.map(r => r.status === 'fulfilled' ? r.value : r.reason);

    const successCount = finalResults.filter(r => r.success).length;
    const errorCount = finalResults.filter(r => !r.success).length;
    console.log(`🏁 Parallel image generation completed: ${successCount} successful, ${errorCount} failed`);

    return finalResults;
}


---
File: /infinite_canvas_v5/src/canvasRenderer.js
---

// Canvas Renderer Module
// Handles all drawing operations on the HTML5 canvas

import { calculateMarkdownHeight } from './markdownParser.js';
import { renderMarkdownToCanvas } from './markdownRenderer.js';

// Main rendering function for the modular canvas system
export function renderCanvas(ctx, canvas, canvasState, inputHandler, uiManager) {
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Save context and apply transformations
    ctx.save();
    ctx.translate(canvasState.offsetX, canvasState.offsetY);
    ctx.scale(canvasState.scale, canvasState.scale);

    // Draw grid
    drawGrid(ctx, canvasState.offsetX, canvasState.offsetY, canvasState.scale, canvas.width, canvas.height);

    // Update visible nodes for viewport culling
    updateVisibleNodes(canvasState, canvas);

    // Draw connections first (behind nodes)
    const visibleNodeIds = new Set(Array.from(canvasState.visibleNodes).map(n => n.id && n.id.toString()));
    const visibleConnections = canvasState.connections.filter(connection => {
        // Handle both old and new connection formats during transition
        const fromNodeId = connection.fromNode || connection.from;
        const toNodeId = connection.toNode || connection.to;
        return fromNodeId && toNodeId && 
               (visibleNodeIds.has(fromNodeId.toString()) || visibleNodeIds.has(toNodeId.toString()));
    });
    
    visibleConnections.forEach(connection => {
        const isSelected = canvasState.selectedConnection && canvasState.selectedConnection.id === connection.id;
        drawConnection(ctx, connection, canvasState.nodes, isSelected);
    });

    // Draw visible nodes
    canvasState.visibleNodes.forEach(node => {
        // Show connection points for selected nodes or when hovering near connection areas
        const showConnectionPoints = 
            node.isSelected || 
            (inputHandler.hoveredNode === node && 
             !inputHandler.isConnecting && 
             !inputHandler.isDragging && 
             !inputHandler.isResizing &&
             isHoveringNearConnectionPoint(inputHandler, node, canvasState));
        
        const showResizeHandles = node.isSelected && !showConnectionPoints;
        
        // Pass hover state information to drawNode for enhanced connection point rendering
        const nodeHoverInfo = {
            isHovered: inputHandler.hoveredNode === node,
            isConnecting: inputHandler.isConnecting,
            hoveredConnectionPoint: null
        };
        
        // Detect which specific connection point is being hovered
        if (nodeHoverInfo.isHovered && !inputHandler.isDragging && !inputHandler.isResizing) {
            const canvasX = (inputHandler.lastMouseX - canvasState.offsetX) / canvasState.scale;
            const canvasY = (inputHandler.lastMouseY - canvasState.offsetY) / canvasState.scale;
            nodeHoverInfo.hoveredConnectionPoint = getConnectionPointAt(node, canvasX, canvasY);
        }
        
        drawNode(ctx, node, showConnectionPoints, showResizeHandles, nodeHoverInfo);

        // Highlight potential connection target when connecting
        if (inputHandler.isConnecting && inputHandler.hoveredNode === node && node !== inputHandler.connectionStart) {
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(node.x - 5, node.y - 5, node.width + 10, node.height + 10);
            ctx.setLineDash([]);
        }

        // Draw generated content (images/videos)
        drawGeneratedContent(ctx, node, canvas, canvasState);
    });

    // Draw connection preview if connecting
    if (inputHandler.isConnecting && inputHandler.connectionStart) {
        drawConnectionPreview(
            ctx, 
            inputHandler.connectionStart, 
            inputHandler.lastMouseX || 0, 
            inputHandler.lastMouseY || 0, 
            canvasState.offsetX, 
            canvasState.offsetY, 
            canvasState.scale, 
            inputHandler.connectionStartPoint
        );
    }

    // Draw selection rectangle if selecting
    if (inputHandler.isSelecting) {
        drawSelectionRectangle(ctx, inputHandler.selectionStart, inputHandler.selectionEnd);
    }

    // Restore context
    ctx.restore();

    // Update UI elements that depend on canvas state
    updateUIElements(canvasState, canvas, uiManager);
}

// Helper function to check if mouse is hovering near connection points
function isHoveringNearConnectionPoint(inputHandler, node, canvasState) {
    if (!inputHandler.lastMouseX || !inputHandler.lastMouseY) return false;

    const canvasX = (inputHandler.lastMouseX - canvasState.offsetX) / canvasState.scale;
    const canvasY = (inputHandler.lastMouseY - canvasState.offsetY) / canvasState.scale;

    const connectionPoint = getConnectionPointAt(node, canvasX, canvasY);
    return connectionPoint !== null;
}

// Update visible nodes for viewport culling
function updateVisibleNodes(canvasState, canvas) {
    const viewport = getViewportBounds(canvasState, canvas);
    canvasState.visibleNodes.clear();

    canvasState.nodes.forEach(node => {
        if (isNodeVisible(node, viewport)) {
            canvasState.visibleNodes.add(node);
        }
    });
}

// Calculate viewport bounds in canvas coordinates
function getViewportBounds(canvasState, canvas) {
    const left = -canvasState.offsetX / canvasState.scale;
    const top = -canvasState.offsetY / canvasState.scale;
    const right = left + canvas.width / canvasState.scale;
    const bottom = top + canvas.height / canvasState.scale;

    return { left, top, right, bottom };
}

// Check if node is visible in current viewport
function isNodeVisible(node, viewport) {
    return !(node.x + node.width < viewport.left ||
            node.x > viewport.right ||
            node.y + node.height < viewport.top ||
            node.y > viewport.bottom);
}

// Draw generated content (images and videos)
function drawGeneratedContent(ctx, node, canvas, canvasState) {
    const isMediaRef = node.isMediaReference;

    // Draw generated image thumbnail if present
    if (node.generatedImageUrl) {
        if (!node._imgObj || node._imgObj.src !== node.generatedImageUrl) {
            node._imgObj = new window.Image();
            node._imgObj.src = node.generatedImageUrl;
            node._imgObj.crossOrigin = 'anonymous'; // Handle CORS for external images
            node._imgObj.onload = () => {
                // Update node dimensions for media references once image is loaded
                if (isMediaRef) {
                    const maxDim = 320;
                    const aspect = node._imgObj.naturalWidth / node._imgObj.naturalHeight;
                    if (aspect >= 1) {
                        node.width = Math.min(maxDim, node._imgObj.naturalWidth);
                        node.height = node.width / aspect;
                    } else {
                        node.height = Math.min(maxDim, node._imgObj.naturalHeight);
                        node.width = node.height * aspect;
                    }
                }
            };
            node._imgObj.onerror = () => {
                // Fallback for images that fail to load
                console.warn('Failed to load image:', node.generatedImageUrl);
            };
        }
        if (node._imgObj.complete && node._imgObj.naturalWidth > 0) {
            // For media references draw the image directly inside the node bounds
            if (isMediaRef) {
                const headerHeight = node._headerHeight || 50;
                const imageY = node.y + headerHeight;
                const imageHeight = node.height - headerHeight;
                ctx.drawImage(node._imgObj, node.x, imageY, node.width, imageHeight);
            } else {
                const maxWidth = Math.min(320, node.width - 20);
                const maxHeight = 240;
                const originalWidth = node._imgObj.naturalWidth;
                const originalHeight = node._imgObj.naturalHeight;
                const aspectRatio = originalWidth / originalHeight;
                let thumbWidth, thumbHeight;
                if (aspectRatio > maxWidth / maxHeight) {
                    thumbWidth = maxWidth;
                    thumbHeight = maxWidth / aspectRatio;
                } else {
                    thumbHeight = maxHeight;
                    thumbWidth = maxHeight * aspectRatio;
                }
                const imgX = node.x + (node.width - thumbWidth) / 2;
                const imgY = node.y + node.height + 10;
                ctx.drawImage(node._imgObj, imgX, imgY, thumbWidth, thumbHeight);
            }
        }
    }

    // Handle video positioning (videos and iframes are positioned absolutely in DOM)
    if (node.generatedVideoUrl) {
        // Handle YouTube and other platform videos with iframe
        if (node.isYouTubeVideo || isVideoUrl(node.generatedVideoUrl)) {
            if (!node._iframeObj || node._iframeObj.src !== getEmbedUrl(node.generatedVideoUrl)) {
                // Remove old iframe if it exists and is still in the DOM
                if (node._iframeObj) {
                    try {
                        if (node._iframeObj.parentNode) {
                            node._iframeObj.parentNode.removeChild(node._iframeObj);
                        }
                    } catch (e) {
                        console.warn('Failed to remove iframe:', e);
                    }
                    node._iframeObj = null;
                }
                
                node._iframeObj = document.createElement('iframe');
                node._iframeObj.src = getEmbedUrl(node.generatedVideoUrl);
                node._iframeObj.frameBorder = '0';
                node._iframeObj.allowFullscreen = true;
                node._iframeObj.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
                node._iframeObj.style.position = 'absolute';
                node._iframeObj.style.pointerEvents = 'auto';
                node._iframeObj.style.zIndex = '1000';
                node._iframeObj.style.border = 'none';
                node._iframeObj.style.borderRadius = '0 0 8px 8px'; // Rounded bottom corners only
                document.body.appendChild(node._iframeObj);
            }
            
            // Position the iframe below the header for media references
            const rect = canvas.getBoundingClientRect();
            const headerHeight = node._headerHeight || 50;
            
            // Limit iframe scaling to prevent controls from becoming too large
            // Cap the effective scale at 1.5x for better usability
            const maxVideoScale = 1.5;
            const effectiveScale = Math.min(canvasState.scale, maxVideoScale);
            
            const iframeX = rect.left + node.x * canvasState.scale + canvasState.offsetX;
            const iframeY = rect.top + (node.y + (isMediaRef ? headerHeight : node.height + 10)) * canvasState.scale + canvasState.offsetY;
            const iframeWidth = node.width * effectiveScale;
            const iframeHeight = (node.height - (isMediaRef ? headerHeight : 0)) * effectiveScale;
            
            if (node._iframeObj && node._iframeObj.style) {
                node._iframeObj.style.left = iframeX + 'px';
                node._iframeObj.style.top = iframeY + 'px';
                node._iframeObj.style.width = iframeWidth + 'px';
                node._iframeObj.style.height = iframeHeight + 'px';
                node._iframeObj.style.display = 'block';
            }
        }
        // Handle regular video files
        else {
            if (!node._videoObj || node._videoObj.src !== node.generatedVideoUrl) {
                node._videoObj = document.createElement('video');
                node._videoObj.src = node.generatedVideoUrl;
                node._videoObj.muted = true;
                node._videoObj.loop = true;
                node._videoObj.controls = true;
                node._videoObj.preload = 'metadata';
                node._videoObj.style.position = 'absolute';
                node._videoObj.style.pointerEvents = 'auto';
                node._videoObj.style.zIndex = '1000';
                node._videoObj.style.borderRadius = '0 0 8px 8px';
                document.body.appendChild(node._videoObj);
            }
            
            if (node._videoObj.readyState >= 1) {
                const rect = canvas.getBoundingClientRect();
                const headerHeight = node._headerHeight || 50;
                
                // Limit video scaling to prevent controls from becoming too large
                // Cap the effective scale at 1.5x for better usability
                const maxVideoScale = 1.5;
                const effectiveScale = Math.min(canvasState.scale, maxVideoScale);
                
                // Position video below the header for media references, or below the node for regular nodes
                const videoX = rect.left + node.x * canvasState.scale + canvasState.offsetX;
                const videoY = rect.top + (node.y + (isMediaRef ? headerHeight : node.height + 10)) * canvasState.scale + canvasState.offsetY;
                const videoWidth = node.width * effectiveScale;
                const videoHeight = (node.height - (isMediaRef ? headerHeight : 0)) * effectiveScale;
                
                if (node._videoObj.style) {
                    node._videoObj.style.left = videoX + 'px';
                    node._videoObj.style.top = videoY + 'px';
                    node._videoObj.style.width = videoWidth + 'px';
                    node._videoObj.style.height = videoHeight + 'px';
                    node._videoObj.style.display = 'block';
                }
            } else {
                if (node._videoObj && node._videoObj.style) {
                    node._videoObj.style.display = 'none';
                }
            }
        }
    }
}

// Helper function to check if URL is from a video platform
function isVideoUrl(url) {
    const videoSites = [
        'vimeo.com',
        'dailymotion.com',
        'twitch.tv',
        'tiktok.com',
        'instagram.com',
        'twitter.com',
        'x.com'
    ];
    
    try {
        const urlObj = new URL(url);
        return videoSites.some(site => urlObj.hostname.includes(site));
    } catch {
        return false;
    }
}

// Helper function to convert various video URLs to embeddable URLs
function getEmbedUrl(url) {
    try {
        const urlObj = new URL(url);
        
        // YouTube
        if (urlObj.hostname.includes('youtube.com')) {
            const videoId = urlObj.searchParams.get('v');
            if (videoId) {
                return `https://www.youtube.com/embed/${videoId}`;
            }
        } else if (urlObj.hostname.includes('youtu.be')) {
            const videoId = urlObj.pathname.slice(1);
            if (videoId) {
                return `https://www.youtube.com/embed/${videoId}`;
            }
        }
        
        // Vimeo
        else if (urlObj.hostname.includes('vimeo.com')) {
            const videoId = urlObj.pathname.split('/').pop();
            if (videoId) {
                return `https://player.vimeo.com/video/${videoId}`;
            }
        }
        
        // For other platforms, return the original URL (may not always work)
        return url;
    } catch {
        return url;
    }
}

// Update UI elements that depend on canvas state
function updateUIElements(canvasState, canvas, uiManager) {
    // Hide videos and iframes for nodes that are not visible
    canvasState.nodes.forEach(node => {
        if (node._videoObj && node._videoObj.style && !canvasState.visibleNodes.has(node)) {
            node._videoObj.style.display = 'none';
        }
        if (node._iframeObj && node._iframeObj.style && !canvasState.visibleNodes.has(node)) {
            node._iframeObj.style.display = 'none';
        }
    });

    // Update tooltip position for selected nodes
    if (uiManager) {
        uiManager.updateGenerateIdeasTooltip();
        uiManager.updateSelectionStatus();
    }
}

export function drawGrid(ctx, offsetX, offsetY, scale, canvasWidth, canvasHeight) {
    const gridSize = 40;
    const startX = Math.floor(-offsetX / scale / gridSize) * gridSize;
    const startY = Math.floor(-offsetY / scale / gridSize) * gridSize;
    const endX = startX + (canvasWidth / scale) + gridSize;
    const endY = startY + (canvasHeight / scale) + gridSize;
    
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5;
    
    for (let x = startX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
    }
    
    for (let y = startY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
}

export function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });
    
    if (currentLine) {
        lines.push(currentLine);
    }
    
    return lines;
}

export function drawNode(ctx, node, showConnectionPoints = false, showResizeHandles = true, hoverInfo = null) {
    if (node.isMediaReference) {
        ctx.save(); // Save context state before drawing media reference node
        
        const headerHeight = 50; // Increased from 30px to 50px for easier dragging
        
        // Draw header/handle area at the top
        ctx.fillStyle = node.isSelected ? '#2d3748' : '#1a202c';
        ctx.fillRect(node.x, node.y, node.width, headerHeight);
        
        // Draw header border
        ctx.strokeStyle = node.isSelected ? '#4299e1' : '#4a5568';
        ctx.lineWidth = node.isSelected ? 2 : 1;
        ctx.strokeRect(node.x, node.y, node.width, headerHeight);
        
        // Add drag handle icon/text in the header - better positioning
        ctx.fillStyle = '#9ca3af';
        ctx.font = '14px Arial'; // Slightly larger font
        
        // Display node name/text if it exists, otherwise show drag handle
        const displayText = (node.name && node.name.trim() !== '') ? node.name : 
                           (node.text && node.text.trim() !== '') ? node.text : null;
        
        if (displayText) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 12px Arial';
            const nameText = displayText.length > 25 ? displayText.substring(0, 25) + '...' : displayText;
            ctx.fillText(nameText, node.x + 8, node.y + 16);
            
            // Show drag handle icon on the right
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px Arial';
            ctx.fillText('⋮⋮', node.x + node.width - 25, node.y + 16);
        } else {
            // Show default drag handle text centered
            ctx.textAlign = 'center';
            ctx.fillText('⋮⋮ Media Node ⋮⋮', node.x + node.width / 2, node.y + 16);
            ctx.textAlign = 'left'; // Reset alignment
        }
        
        // Additional drag hint
        ctx.fillStyle = '#6b7280';
        ctx.font = '10px Arial';
        const hintText = displayText ? 'Double-click to edit name' : 'Double-click to add name';
        ctx.fillText(hintText, node.x + 8, node.y + 35);
        
        // Draw selection border for the entire node if selected
        if (node.isSelected) {
            ctx.strokeStyle = '#4299e1';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.strokeRect(node.x, node.y, node.width, node.height);
            ctx.setLineDash([]); // Reset dash pattern
        }
        
        // Draw connection points for media nodes when requested
        if (showConnectionPoints) {
            drawConnectionPoints(ctx, node, hoverInfo);
        }

        // Draw resize handles for media nodes when requested
        if (showResizeHandles && node.isSelected) {
            drawResizeHandles(ctx, node);
        }
        
        ctx.restore(); // Restore context state
        
        // Store header height for interaction detection
        node._headerHeight = headerHeight;
        return;
    }
    const { x, y, width, text, isSelected, generatedByModel, maxHeight = 400, scrollY = 0 } = node;

    // Enhanced margin configuration for better text spacing
    const margins = {
        top: 32,    // Increased from 28 to 32 for better grabbability and visual balance
        bottom: 12, // Bottom margin
        left: 12,   // Left margin
        right: 12   // Right margin
    };

    const minHeight = 80; // Increased from 60 to 80 to align with new default height

    // Calculate required height based on markdown content with new margins
    const requiredHeight = Math.max(minHeight, calculateMarkdownHeight(ctx, text, width, margins, node.fontSize || 14));

    // Only auto-adjust height if node hasn't been manually resized, but respect maxHeight
    if (!node.manuallyResized) {
        node.height = Math.min(requiredHeight, maxHeight);
    }

    const height = node.height;

    // Store the full content height for scrolling calculations
    node.contentHeight = requiredHeight;

    // Draw model attribution above the node if it was generated by AI
    if (generatedByModel) {
        ctx.save();
        ctx.font = '14px Arial';
        ctx.fillStyle = '#9ca3af';
        ctx.textAlign = 'center';

        // Position the text above the node
        const modelText = `🤖 ${generatedByModel}`;
        const textX = x + width / 2;
        const textY = y - 10;

        // Draw a small background for better readability
        const textMetrics = ctx.measureText(modelText);
        const textWidth = textMetrics.width;
        const textHeight = 16;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(textX - textWidth/2 - 4, textY - textHeight + 2, textWidth + 8, textHeight);

        ctx.fillStyle = '#9ca3af';
        ctx.fillText(modelText, textX, textY);
        ctx.restore();
    }

    // Draw node background
    ctx.fillStyle = isSelected ? '#2d3748' : '#1a202c';
    ctx.fillRect(x, y, width, height);

    // Draw node border
    ctx.strokeStyle = isSelected ? '#4299e1' : '#4a5568';
    ctx.lineWidth = isSelected ? 2 : 1;
    ctx.strokeRect(x, y, width, height);

    // Draw connection points first if requested (they should be most prominent)
    if (showConnectionPoints) {
        drawConnectionPoints(ctx, node, hoverInfo);
    }

    // Draw resize handles based on the showResizeHandles parameter
    // This reduces visual clutter and prioritizes connection functionality
    if (showResizeHandles && isSelected) {
        drawResizeHandles(ctx, node);
    }

    // Render markdown content with enhanced margins and scrolling support
    renderMarkdownToCanvas(ctx, text, x, y, width, height, margins, node.scrollY || 0, node.fontSize || 14);

    // Draw scroll indicator if content is scrollable and node is selected
    if (node.contentHeight > height && isSelected) {
        drawScrollIndicator(ctx, node);
    }
}

export function drawScrollIndicator(ctx, node) {
    const { x, y, width, height, contentHeight, scrollY = 0 } = node;

    if (contentHeight <= height) return; // No scrolling needed

    // Calculate scrollbar dimensions
    const scrollbarWidth = 8;
    const scrollbarX = x + width - scrollbarWidth - 4;
    const scrollbarY = y + 4;
    const scrollbarHeight = height - 8;

    // Calculate thumb position and size
    const thumbHeight = Math.max(20, (height / contentHeight) * scrollbarHeight);
    const maxScrollY = contentHeight - height;
    const thumbY = scrollbarY + (scrollY / maxScrollY) * (scrollbarHeight - thumbHeight);

    // Draw scrollbar track
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.fillRect(scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight);

    // Draw scrollbar thumb
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.fillRect(scrollbarX, thumbY, scrollbarWidth, thumbHeight);
}

export function drawConnectionPoints(ctx, node, hoverInfo = null) {
    ctx.save(); // Save context state
    
    const { x, y, width, height } = node;
    const pointRadius = 12; // Optimized size for organized connectors

    // Calculate connection point positions - exactly 4 points
    const points = getConnectionPoints(node);

    // Draw each connection point with professional styling
    points.forEach((point) => {
        // Check if this specific connection point is being hovered
        const isHovered = hoverInfo && hoverInfo.hoveredConnectionPoint && 
                         hoverInfo.hoveredConnectionPoint.side === point.side;
        
        // Enhance visual feedback for hovered connection points
        const currentRadius = isHovered ? pointRadius + 4 : pointRadius;
        const shadowIntensity = isHovered ? 1.0 : 0.6;
        const shadowBlurRadius = isHovered ? 20 : 12;
        
        // Create organized connector appearance with enhanced hover states
        ctx.shadowColor = `rgba(34, 197, 94, ${shadowIntensity})`;
        ctx.shadowBlur = shadowBlurRadius;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // Outer ring - different colors for each side for better organization
        const sideColors = {
            'top': '#10b981',    // Emerald green
            'right': '#3b82f6',  // Blue  
            'bottom': '#f59e0b', // Amber
            'left': '#ef4444'    // Red
        };
        
        ctx.fillStyle = sideColors[point.side] || '#10b981';
        ctx.strokeStyle = isHovered ? '#fbbf24' : '#ffffff'; // Golden highlight when hovered
        ctx.lineWidth = isHovered ? 4 : 3;

        ctx.beginPath();
        ctx.arc(point.x, point.y, currentRadius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        // Inner circle for depth - enhanced when hovered
        ctx.shadowBlur = 0; // Remove shadow for inner elements
        ctx.fillStyle = isHovered ? 'rgba(255, 255, 255, 1.0)' : 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.arc(point.x, point.y, currentRadius - 4, 0, 2 * Math.PI);
        ctx.fill();

        // Center indicator dot - larger when hovered
        ctx.fillStyle = sideColors[point.side] || '#10b981';
        ctx.beginPath();
        ctx.arc(point.x, point.y, isHovered ? 4 : 3, 0, 2 * Math.PI);
        ctx.fill();

        // Add directional indicator (small arrow or line)
        ctx.strokeStyle = sideColors[point.side] || '#10b981';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Draw directional indicator based on side
        switch(point.side) {
            case 'top':
                ctx.moveTo(point.x, point.y - 6);
                ctx.lineTo(point.x, point.y - 2);
                break;
            case 'right': 
                ctx.moveTo(point.x + 6, point.y);
                ctx.lineTo(point.x + 2, point.y);
                break;
            case 'bottom':
                ctx.moveTo(point.x, point.y + 6);
                ctx.lineTo(point.x, point.y + 2);
                break;
            case 'left':
                ctx.moveTo(point.x - 6, point.y);
                ctx.lineTo(point.x - 2, point.y);
                break;
        }
        ctx.stroke();
    });

    ctx.restore(); // Restore context state
}

// Function to draw visual resize handles on selected nodes
export function drawResizeHandles(ctx, node) {
    ctx.save(); // Save context state
    
    const { x, y, width, height } = node;
    const handleSize = 12; // Slightly smaller to be less prominent
    const handleColor = '#6b7280'; // More subtle gray color
    const handleBorderColor = '#9ca3af'; // Light gray border for subtlety

    // Calculate handle positions
    const handles = [
        { x: x - handleSize/2, y: y - handleSize/2, type: 'top-left' },           // Top-left
        { x: x + width/2 - handleSize/2, y: y - handleSize/2, type: 'top' },      // Top-center
        { x: x + width - handleSize/2, y: y - handleSize/2, type: 'top-right' },  // Top-right
        { x: x + width - handleSize/2, y: y + height/2 - handleSize/2, type: 'right' }, // Right-center
        { x: x + width - handleSize/2, y: y + height - handleSize/2, type: 'bottom-right' }, // Bottom-right
        { x: x + width/2 - handleSize/2, y: y + height - handleSize/2, type: 'bottom' }, // Bottom-center
        { x: x - handleSize/2, y: y + height - handleSize/2, type: 'bottom-left' }, // Bottom-left
        { x: x - handleSize/2, y: y + height/2 - handleSize/2, type: 'left' }     // Left-center
    ];

    // Draw each handle with subtle styling
    handles.forEach(handle => {
        // Subtle shadow for depth
        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;

        // Draw handle background with subtle styling
        ctx.fillStyle = handleColor;
        ctx.strokeStyle = handleBorderColor;
        ctx.lineWidth = 2; // Thinner border for subtlety

        ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
        ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);
    });

    ctx.restore(); // Restore context state
}

// Helper function to check if a point is over a resize handle
export function getResizeHandleAt(node, x, y) {
    const handleSize = 14; // Match the increased visual size
    const tolerance = 8; // Much larger tolerance for very easy clicking
    const effectiveSize = handleSize + tolerance * 2;

    // Calculate handle positions (same as in drawResizeHandles)
    const handles = [
        { x: node.x - handleSize/2, y: node.y - handleSize/2, type: 'top-left' },
        { x: node.x + node.width/2 - handleSize/2, y: node.y - handleSize/2, type: 'top' },
        { x: node.x + node.width - handleSize/2, y: node.y - handleSize/2, type: 'top-right' },
        { x: node.x + node.width - handleSize/2, y: node.y + node.height/2 - handleSize/2, type: 'right' },
        { x: node.x + node.width - handleSize/2, y: node.y + node.height - handleSize/2, type: 'bottom-right' },
        { x: node.x + node.width/2 - handleSize/2, y: node.y + node.height - handleSize/2, type: 'bottom' },
        { x: node.x - handleSize/2, y: node.y + node.height - handleSize/2, type: 'bottom-left' },
        { x: node.x - handleSize/2, y: node.y + node.height/2 - handleSize/2, type: 'left' }
    ];

    // Check if click is within any handle with generous tolerance
    for (const handle of handles) {
        if (x >= handle.x - tolerance && x <= handle.x + effectiveSize &&
            y >= handle.y - tolerance && y <= handle.y + effectiveSize) {
            return handle.type;
        }
    }

    return null;
}

// Helper function to get connection point coordinates
export function getConnectionPoints(node) {
    const { x, y, width, height } = node;

    return [
        { x: x + width / 2, y: y, side: 'top' },           // Top center
        { x: x + width, y: y + height / 2, side: 'right' }, // Right center
        { x: x + width / 2, y: y + height, side: 'bottom' }, // Bottom center
        { x: x, y: y + height / 2, side: 'left' }          // Left center
    ];
}

// Helper function to check if a point is over a connection point
export function getConnectionPointAt(node, x, y) {
    const points = getConnectionPoints(node);
    const pointRadius = 16; // Adjusted detection radius for organized connectors (12 + 4 tolerance)

    for (const point of points) {
        const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
        if (distance <= pointRadius) {
            return point;
        }
    }
    return null;
}

// Helper function to calculate intersection of line with rectangle
function getLineRectangleIntersection(centerX, centerY, targetX, targetY, rectX, rectY, rectWidth, rectHeight) {
    // Calculate direction vector
    const dx = targetX - centerX;
    const dy = targetY - centerY;

    // If no direction, return center
    if (dx === 0 && dy === 0) {
        return { x: centerX, y: centerY };
    }

    // Calculate intersections with all four edges
    const intersections = [];

    // Left edge (x = rectX)
    if (dx !== 0) {
        const t = (rectX - centerX) / dx;
        const y = centerY + t * dy;
        if (t > 0 && y >= rectY && y <= rectY + rectHeight) {
            intersections.push({ x: rectX, y: y, distance: t });
        }
    }

    // Right edge (x = rectX + rectWidth)
    if (dx !== 0) {
        const t = (rectX + rectWidth - centerX) / dx;
        const y = centerY + t * dy;
        if (t > 0 && y >= rectY && y <= rectY + rectHeight) {
            intersections.push({ x: rectX + rectWidth, y: y, distance: t });
        }
    }

    // Top edge (y = rectY)
    if (dy !== 0) {
        const t = (rectY - centerY) / dy;
        const x = centerX + t * dx;
        if (t > 0 && x >= rectX && x <= rectX + rectWidth) {
            intersections.push({ x: x, y: rectY, distance: t });
        }
    }

    // Bottom edge (y = rectY + rectHeight)
    if (dy !== 0) {
        const t = (rectY + rectHeight - centerY) / dy;
        const x = centerX + t * dx;
        if (t > 0 && x >= rectX && x <= rectX + rectWidth) {
            intersections.push({ x: x, y: rectY + rectHeight, distance: t });
        }
    }

    // Return the closest intersection
    if (intersections.length > 0) {
        const closest = intersections.reduce((min, curr) =>
            curr.distance < min.distance ? curr : min
        );
        return { x: closest.x, y: closest.y };
    }

    // Fallback to center if no intersection found
    return { x: centerX, y: centerY };
}

export function drawConnection(ctx, connection, nodes, isSelected = false) {
    // Handle both old and new connection formats during transition
    const fromNodeId = connection.fromNode || connection.from;
    const toNodeId = connection.toNode || connection.to;
    
    // Skip connections with missing data
    if (!fromNodeId || !toNodeId) return;
    
    const fromNode = nodes.find(n => n.id && n.id.toString() === fromNodeId.toString());
    const toNode = nodes.find(n => n.id && n.id.toString() === toNodeId.toString());

    if (!fromNode || !toNode) return;

    // Get organized connection points for both nodes
    const fromPoints = getConnectionPoints(fromNode);
    const toPoints = getConnectionPoints(toNode);

    // Find the best connection points (closest pair)
    let bestFromPoint = fromPoints[0];
    let bestToPoint = toPoints[0]; 
    let shortestDistance = Infinity;

    // Use stored connection points if available, otherwise find the closest pair
    const fromSide = connection.fromSide || connection.fromPoint;
    const toSide = connection.toSide || connection.toPoint;
    
    if (fromSide && toSide) {
        // Use specific connection points if they were stored
        bestFromPoint = fromPoints.find(p => p.side === fromSide) || fromPoints[0];
        bestToPoint = toPoints.find(p => p.side === toSide) || toPoints[0];
    } else {
        // Find the closest connection points automatically
        fromPoints.forEach(fromPoint => {
            toPoints.forEach(toPoint => {
                const distance = Math.sqrt(
                    Math.pow(toPoint.x - fromPoint.x, 2) + 
                    Math.pow(toPoint.y - fromPoint.y, 2)
                );
                if (distance < shortestDistance) {
                    shortestDistance = distance;
                    bestFromPoint = fromPoint;
                    bestToPoint = toPoint;
                }
            });
        });
    }

    // Calculate angle for arrow head using the organized connection points
    const angle = Math.atan2(bestToPoint.y - bestFromPoint.y, bestToPoint.x - bestFromPoint.x);

    // Calculate arrow position with offset to ensure visibility
    const arrowOffset = 16; // Adjusted for organized connectors
    const arrowX = bestToPoint.x - Math.cos(angle) * arrowOffset;
    const arrowY = bestToPoint.y - Math.sin(angle) * arrowOffset;

    // Draw line with enhanced styling - different colors for selected state
    if (isSelected) {
        ctx.strokeStyle = '#2196f3'; // Blue for selected
        ctx.lineWidth = 4; // Thicker when selected
    } else {
        ctx.strokeStyle = '#a0a0a0'; // Light gray for better aesthetics with dark theme
        ctx.lineWidth = 3;
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Add subtle shadow for depth
    if (isSelected) {
        ctx.shadowColor = 'rgba(33, 150, 243, 0.4)';
    } else {
        ctx.shadowColor = 'rgba(128, 128, 128, 0.3)';
    }
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;

    ctx.beginPath();
    ctx.moveTo(bestFromPoint.x, bestFromPoint.y);
    ctx.lineTo(arrowX, arrowY);
    ctx.stroke();

    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Draw arrowhead at the offset position with selection state
    drawArrowhead(ctx, arrowX, arrowY, angle, isSelected);
}

export function drawArrowhead(ctx, x, y, angle, isSelected = false) {
    const arrowLength = 18; // Larger arrow for organized connectors
    const arrowAngle = Math.PI / 6; // Narrower angle (30 degrees) for cleaner appearance

    // Enhanced shadow for the arrowhead
    if (isSelected) {
        ctx.shadowColor = 'rgba(33, 150, 243, 0.6)';
    } else {
        ctx.shadowColor = 'rgba(128, 128, 128, 0.5)';
    }
    ctx.shadowBlur = 6;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    // Professional arrow colors - consistent with organized connector theme
    if (isSelected) {
        ctx.fillStyle = '#2196f3'; // Bright blue for selected
        ctx.strokeStyle = '#1565c0'; // Darker blue border
    } else {
        ctx.fillStyle = '#6b7280'; // Professional gray
        ctx.strokeStyle = '#374151'; // Darker gray border
    }
    ctx.lineWidth = 2;

    // Draw filled arrow with clean geometry
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(
        x - arrowLength * Math.cos(angle - arrowAngle),
        y - arrowLength * Math.sin(angle - arrowAngle)
    );
    ctx.lineTo(
        x - arrowLength * 0.6 * Math.cos(angle), // Create slight indentation for better arrow shape
        y - arrowLength * 0.6 * Math.sin(angle)
    );
    ctx.lineTo(
        x - arrowLength * Math.cos(angle + arrowAngle),
        y - arrowLength * Math.sin(angle + arrowAngle)
    );
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
}

export function drawConnectionPreview(ctx, connectionStart, lastMouseX, lastMouseY, offsetX, offsetY, scale, connectionPoint = null) {
    if (!connectionStart) return;

    const canvasX = (lastMouseX - offsetX) / scale;
    const canvasY = (lastMouseY - offsetY) / scale;

    // Use connection point if provided, otherwise use node center
    let fromX, fromY;
    if (connectionPoint) {
        fromX = connectionPoint.x;
        fromY = connectionPoint.y;
    } else {
        fromX = connectionStart.x + connectionStart.width / 2;
        fromY = connectionStart.y + connectionStart.height / 2;
    }

    // Draw dashed preview line
    ctx.strokeStyle = '#2196f3';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(canvasX, canvasY);
    ctx.stroke();
    ctx.setLineDash([]);
}

// Helper function to calculate distance from a point to a line segment
function distanceToLineSegment(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;

    if (lenSq === 0) {
        // Line segment is actually a point
        return Math.sqrt(A * A + B * B);
    }

    let param = dot / lenSq;

    let xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

// Helper function to check if a point is on a connection
export function getConnectionAtPoint(x, y, connections, nodes, tolerance = 8) {
    for (const connection of connections) {
        // Handle both old and new connection formats during transition
        const fromNodeId = connection.fromNode || connection.from;
        const toNodeId = connection.toNode || connection.to;
        
        // Skip connections with missing data
        if (!fromNodeId || !toNodeId) continue;
        
        const fromNode = nodes.find(n => n.id && n.id.toString() === fromNodeId.toString());
        const toNode = nodes.find(n => n.id && n.id.toString() === toNodeId.toString());

        if (!fromNode || !toNode) continue;

        // Get organized connection points for both nodes
        const fromPoints = getConnectionPoints(fromNode);
        const toPoints = getConnectionPoints(toNode);

        // Find the best connection points (same logic as drawConnection)
        let bestFromPoint = fromPoints[0];
        let bestToPoint = toPoints[0]; 
        let shortestDistance = Infinity;

        // Use stored connection points if available, otherwise find the closest pair
        const fromSide = connection.fromSide || connection.fromPoint;
        const toSide = connection.toSide || connection.toPoint;
        
        if (fromSide && toSide) {
            bestFromPoint = fromPoints.find(p => p.side === fromSide) || fromPoints[0];
            bestToPoint = toPoints.find(p => p.side === toSide) || toPoints[0];
        } else {
            // Find the closest connection points automatically
            fromPoints.forEach(fromPoint => {
                toPoints.forEach(toPoint => {
                    const distance = Math.sqrt(
                        Math.pow(toPoint.x - fromPoint.x, 2) + 
                        Math.pow(toPoint.y - fromPoint.y, 2)
                    );
                    if (distance < shortestDistance) {
                        shortestDistance = distance;
                        bestFromPoint = fromPoint;
                        bestToPoint = toPoint;
                    }
                });
            });
        }

        // Calculate arrow position with offset
        const angle = Math.atan2(bestToPoint.y - bestFromPoint.y, bestToPoint.x - bestFromPoint.x);
        const arrowOffset = 16;
        const arrowX = bestToPoint.x - Math.cos(angle) * arrowOffset;
        const arrowY = bestToPoint.y - Math.sin(angle) * arrowOffset;

        // Check if point is close to the line segment using organized connection points
        const distance = distanceToLineSegment(x, y, bestFromPoint.x, bestFromPoint.y, arrowX, arrowY);

        if (distance <= tolerance) {
            return connection;
        }
    }

    return null;
}

export function drawSelectionRectangle(ctx, selectionStart, selectionEnd) {
    if (!selectionStart || !selectionEnd) return;

    const x = Math.min(selectionStart.x, selectionEnd.x);
    const y = Math.min(selectionStart.y, selectionEnd.y);
    const width = Math.abs(selectionEnd.x - selectionStart.x);
    const height = Math.abs(selectionEnd.y - selectionStart.y);

    // Draw selection rectangle background
    ctx.fillStyle = 'rgba(66, 153, 225, 0.1)';
    ctx.fillRect(x, y, width, height);

    // Draw selection rectangle border
    ctx.strokeStyle = '#4299e1';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(x, y, width, height);
    ctx.setLineDash([]);
}


---
File: /infinite_canvas_v5/src/CanvasState.js
---

// CanvasState.js - Handles all canvas data, persistence, and history
export class CanvasState {
    constructor() {
        // Core canvas data
        this.nodes = [];
        this.connections = [];
        this.selectedNodes = [];
        this.selectedConnection = null;
        
        // View state
        this.offsetX = 0;
        this.offsetY = 0;
        this.scale = 1.0;
        this.globalFontSize = 14;
        
        // History for undo/redo
        this.history = [];
        this.historyIndex = -1;
        this.maxHistorySize = 100;
        
        // Copy/paste clipboard
        this.clipboard = {
            nodes: [],
            connections: []
        };
        
        // Performance optimization
        this.spatialGrid = new Map();
        this.gridSize = 200;
        this.visibleNodes = new Set();
    }
    
    // Node management - using Obsidian Canvas format
    createNode(text = 'New Node', x = null, y = null, generatedByModel = null, { save = true } = {}) {
        const node = {
            id: (Date.now() + Math.random()).toString(),
            type: "text",
            text: text,
            x: x !== null ? x : 400,
            y: y !== null ? y : 300,
            width: 360,
            height: 140,
            // Internal properties (not part of Obsidian format but needed for our functionality)
            maxHeight: 400,
            scrollY: 0,
            isSelected: false,
            generatedByModel: generatedByModel,
            fontSize: this.globalFontSize,
            // Per-node generation states to allow simultaneous AI operations
            isGeneratingAI: false,
            isGeneratingImage: false,
            isGeneratingVideo: false,
            isGeneratingContext: false,
            isGeneratingReference: false,
            isUploadingImage: false
        };

        this.nodes.push(node);
        this.addNodeToGrid(node);
        if (save) {
            this.saveState();
        }
        return node;
    }
    
    deleteSelectedNodes() {
        if (this.selectedNodes.length === 0) return;

        const nodeIdsToDelete = new Set(this.selectedNodes.map(node => node.id));

        // Clean up video and iframe elements
        this.selectedNodes.forEach(node => {
            if (node._videoObj) {
                try {
                    if (node._videoObj.parentNode) {
                        node._videoObj.parentNode.removeChild(node._videoObj);
                    }
                } catch (e) {
                    console.warn('Failed to remove video element:', e);
                }
                node._videoObj = null;
            }
            if (node._iframeObj) {
                try {
                    if (node._iframeObj.parentNode) {
                        node._iframeObj.parentNode.removeChild(node._iframeObj);
                    }
                } catch (e) {
                    console.warn('Failed to remove iframe element:', e);
                }
                node._iframeObj = null;
            }
        });

        // Remove nodes from spatial grid
        this.selectedNodes.forEach(node => this.removeNodeFromGrid(node));

        // Remove the nodes
        this.nodes = this.nodes.filter(node => !nodeIdsToDelete.has(node.id));

        // Remove connections involving these nodes
        this.connections = this.connections.filter(
            conn => !nodeIdsToDelete.has(conn.fromNode) && !nodeIdsToDelete.has(conn.toNode)
        );

        this.saveState();
        this.clearSelection();
    }
    
    // Connection management - using Obsidian Canvas format
    createConnection(fromNode, toNode, fromSide = null, toSide = null) {
        const existingConnection = this.connections.find(
            conn => (conn.fromNode === fromNode.id.toString() && conn.toNode === toNode.id.toString()) ||
                   (conn.fromNode === toNode.id.toString() && conn.toNode === fromNode.id.toString())
        );

        if (!existingConnection) {
            const connection = {
                id: (Date.now() + Math.random()).toString(),
                fromNode: fromNode.id.toString(),
                toNode: toNode.id.toString()
            };
            
            // Add connection points if specified
            if (fromSide) connection.fromSide = fromSide;
            if (toSide) connection.toSide = toSide;
            
            this.connections.push(connection);
            this.saveState();
            return connection;
        }
        return null;
    }
    
    getConnectedNodes(node) {
        if (!node) return [];
        const connectedNodes = [];
        const nodeId = node.id.toString();
        this.connections.forEach(connection => {
            let connectedNodeId = null;
            if (connection.fromNode === nodeId) {
                connectedNodeId = connection.toNode;
            } else if (connection.toNode === nodeId) {
                connectedNodeId = connection.fromNode;
            }
            if (connectedNodeId) {
                const connectedNode = this.nodes.find(n => n.id.toString() === connectedNodeId);
                if (connectedNode) connectedNodes.push(connectedNode);
            }
        });
        return connectedNodes;
    }
    
    getAncestorNodes(node) {
        if (!node) return [];
        const ancestors = [];
        const visited = new Set();
        const nodesToProcess = [node];
        const nodeId = node.id.toString();

        while (nodesToProcess.length > 0) {
            const currentNode = nodesToProcess.shift();
            const currentNodeId = currentNode.id.toString();
            if (visited.has(currentNodeId)) continue;
            visited.add(currentNodeId);

            const parentConnections = this.connections.filter(connection =>
                connection.toNode === currentNodeId
            );

            if (parentConnections.length > 0) {
                parentConnections.forEach(parentConnection => {
                    const parentNode = this.nodes.find(n => n.id.toString() === parentConnection.fromNode);
                    if (parentNode && !visited.has(parentNode.id.toString())) {
                        ancestors.push(parentNode);
                        nodesToProcess.push(parentNode);
                    }
                });
            }
        }
        return ancestors;
    }
    
    // Selection management
    selectNodes(nodes) {
        this.clearSelection();
        if (Array.isArray(nodes)) {
            nodes.forEach(node => {
                if (node) {
                    node.isSelected = true;
                    this.selectedNodes.push(node);
                }
            });
        } else if (nodes) {
            nodes.isSelected = true;
            this.selectedNodes.push(nodes);
        }
    }
    
    addToSelection(node) {
        if (node && !this.selectedNodes.includes(node)) {
            node.isSelected = true;
            this.selectedNodes.push(node);
        }
    }
    
    removeFromSelection(node) {
        if (node) {
            node.isSelected = false;
            const index = this.selectedNodes.indexOf(node);
            if (index > -1) {
                this.selectedNodes.splice(index, 1);
            }
        }
    }
    
    clearSelection() {
        this.nodes.forEach(n => n.isSelected = false);
        this.selectedNodes = [];
        this.selectedConnection = null;
    }
    
    get selectedNode() {
        return this.selectedNodes.length > 0 ? this.selectedNodes[0] : null;
    }
    
    // Copy/Paste
    copySelectedNodes() {
        if (this.selectedNodes.length === 0) return false;
        
        const selectedNodeIds = new Set(this.selectedNodes.map(node => node.id));
        
        this.clipboard.nodes = this.selectedNodes.map(node => ({
            ...node,
            isSelected: false,
            _imgObj: null,
            _videoObj: null
        }));
        
        this.clipboard.connections = this.connections.filter(conn => 
            selectedNodeIds.has(conn.fromNode) && selectedNodeIds.has(conn.toNode)
        ).map(conn => ({ ...conn }));
        
        return true;
    }
    
    pasteNodes() {
        if (this.clipboard.nodes.length === 0) return [];
        
        const oldToNewIdMap = new Map();
        const pastedNodes = [];
        const pasteOffset = { x: 50, y: 50 };
        
        // Create new nodes with new IDs
        this.clipboard.nodes.forEach(originalNode => {
            const newId = Date.now() + Math.random();
            oldToNewIdMap.set(originalNode.id, newId);
            
            const newNode = {
                ...originalNode,
                id: newId,
                x: originalNode.x + pasteOffset.x,
                y: originalNode.y + pasteOffset.y,
                isSelected: true
            };
            
            this.nodes.push(newNode);
            this.addNodeToGrid(newNode);
            pastedNodes.push(newNode);
        });
        
        // Create new connections
        this.clipboard.connections.forEach(originalConnection => {
            const newFromId = oldToNewIdMap.get(originalConnection.fromNode);
            const newToId = oldToNewIdMap.get(originalConnection.toNode);
            
            if (newFromId && newToId) {
                const newConnection = {
                    ...originalConnection,
                    id: (Date.now() + Math.random()).toString(),
                    fromNode: newFromId,
                    toNode: newToId
                };
                this.connections.push(newConnection);
            }
        });
        
        // Update selection
        this.saveState();
        this.nodes.forEach(node => {
            if (!pastedNodes.includes(node)) {
                node.isSelected = false;
            }
        });
        this.selectedNodes = pastedNodes;
        this.selectedConnection = null;
        
        return pastedNodes;
    }
    
    // History management
    saveState() {
        // Clear redo stack if we are in the middle of history
        if (this.historyIndex < this.history.length - 1) {
            this.history.splice(this.historyIndex + 1);
        }

        const state = {
            nodes: JSON.parse(JSON.stringify(this.nodes)),
            connections: JSON.parse(JSON.stringify(this.connections)),
            globalFontSize: this.globalFontSize
        };
        
        this.history.push(state);

        // Enforce history size limit
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
        }
        
        // Update history index to point to the latest state
        this.historyIndex = this.history.length - 1;
    }
    
    undo() {
        if (this.canUndo()) {
            this.historyIndex--;
            this.restoreState(this.history[this.historyIndex]);
            return true;
        }
        return false;
    }
    
    redo() {
        if (this.canRedo()) {
            this.historyIndex++;
            this.restoreState(this.history[this.historyIndex]);
            return true;
        }
        return false;
    }
    
    restoreState(state) {
        // Deep copy to avoid reference issues
        this.nodes = JSON.parse(JSON.stringify(state.nodes));
        this.connections = JSON.parse(JSON.stringify(state.connections));
        this.globalFontSize = state.globalFontSize || 14;

        this.rebuildSpatialGrid();
        this.clearSelection();
    }
    
    canUndo() {
        return this.historyIndex > 0;
    }
    
    canRedo() {
        return this.historyIndex < this.history.length - 1;
    }
    
    // Data persistence
    saveToLocalStorage() {
        // Clean nodes for serialization - remove DOM elements but keep media URLs
        const cleanNodes = this.nodes.map(node => {
            const cleanNode = { ...node };
            // Remove DOM elements that can't be serialized
            delete cleanNode._imgObj;
            delete cleanNode._videoObj; 
            delete cleanNode._iframeObj;
            return cleanNode;
        });

        const data = {
            nodes: cleanNodes,
            connections: this.connections,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            scale: this.scale,
            globalFontSize: this.globalFontSize
        };
        
        try {
            localStorage.setItem('infiniteCanvasMVP', JSON.stringify(data));
            console.log('Canvas state saved successfully');
        } catch (e) {
            console.error('Error saving to localStorage:', e);
        }
    }
    
    loadFromLocalStorage() {
        const saved = localStorage.getItem('infiniteCanvasMVP');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                this.nodes = data.nodes || [];
                this.connections = data.connections || [];
                this.offsetX = data.offsetX || 0;
                this.offsetY = data.offsetY || 0;
                this.scale = data.scale || 1.0;
                this.globalFontSize = data.globalFontSize || 14;

                // Ensure all nodes have fontSize and restore media reference properties
                this.nodes.forEach(node => {
                    if (typeof node.fontSize !== 'number') {
                        node.fontSize = this.globalFontSize;
                    }
                    
                    // Initialize per-node generation states if they don't exist
                    // This ensures compatibility with nodes saved before per-node states were added
                    if (typeof node.isGeneratingAI !== 'boolean') {
                        node.isGeneratingAI = false;
                    }
                    if (typeof node.isGeneratingImage !== 'boolean') {
                        node.isGeneratingImage = false;
                    }
                    if (typeof node.isGeneratingVideo !== 'boolean') {
                        node.isGeneratingVideo = false;
                    }
                    if (typeof node.isGeneratingContext !== 'boolean') {
                        node.isGeneratingContext = false;
                    }
                    if (typeof node.isGeneratingReference !== 'boolean') {
                        node.isGeneratingReference = false;
                    }
                    if (typeof node.isUploadingImage !== 'boolean') {
                        node.isUploadingImage = false;
                    }
                    
                    // Restore media reference node properties
                    if (node.isMediaReference) {
                        // Ensure media reference properties are properly set
                        if (node.generatedImageUrl || node.generatedVideoUrl) {
                            // Set YouTube video flag if it's a YouTube URL
                            if (node.generatedVideoUrl && this.isYouTubeUrl(node.generatedVideoUrl)) {
                                node.isYouTubeVideo = true;
                            }
                            
                            // Ensure header height is set
                            if (!node._headerHeight) {
                                node._headerHeight = 50;
                            }
                        }
                    }
                });

                this.rebuildSpatialGrid();
                console.log('Canvas state loaded successfully');
                return true;
            } catch (e) {
                console.error('Error loading from localStorage:', e);
                this.createDefaultTemplate();
                return false;
            }
        } else {
            this.createDefaultTemplate();
            return false;
        }
    }
    
    // Helper method to check if URL is YouTube
    isYouTubeUrl(url) {
        try {
            const urlObj = new URL(url);
            return urlObj.hostname.includes('youtube.com') || urlObj.hostname.includes('youtu.be');
        } catch {
            return false;
        }
    }
    
    // Create a media reference node (images/videos)
    createMediaNode(url, mediaType, x = 400, y = 300) {
        const defaultWidth = 320;
        const defaultHeight = mediaType === 'image' ? 240 : 270; // Increased video height to account for header

        const node = this.createNode('', x, y, null, { save: false });
        node.width = defaultWidth;
        node.height = defaultHeight;
        node.isMediaReference = true;
        node.manuallyResized = true; // prevent auto resize
        node._headerHeight = 50; // Set header height

        if (mediaType === 'image') {
            node.generatedImageUrl = url;
        } else if (mediaType === 'youtube') {
            node.generatedVideoUrl = url;
            node.isYouTubeVideo = true;
            // Set custom dimensions for YouTube videos (accounting for header)
            node.width = 480;
            node.height = 320; // 270 (16:9 video) + 50 (header) = 320 total
        } else {
            node.generatedVideoUrl = url;
        }

        // Update spatial grid with new size
        this.removeNodeFromGrid(node);
        this.addNodeToGrid(node);

        this.saveState();
        return node;
    }
    
    // Helper to check if a URL is a blob URL (local file)
    isBlobUrl(url) {
        return url && url.startsWith('blob:');
    }
    
    createDefaultTemplate() {
        const centerX = 400;
        const centerY = 300;

        const mainNode = {
            id: Date.now().toString(),
            type: "text",
            x: centerX,
            y: centerY,
            width: 360,
            height: 140,
            text: "Tell me a joke 😄",
            fontSize: 16,
            isSelected: false,
            manuallyResized: false,
            maxHeight: 400,
            contentHeight: 140,
            scrollY: 0,
            // Per-node generation states
            isGeneratingAI: false,
            isGeneratingImage: false,
            isGeneratingVideo: false,
            isGeneratingContext: false,
            isGeneratingReference: false,
            isUploadingImage: false
        };

        const jokes = [
            {
                text: "Why don't scientists trust atoms?\n\n**Because they make up everything!** 🔬",
                x: centerX - 380,
                y: centerY + 150,
                model: "llama-3.3-70b-versatile"
            },
            {
                text: "What do you call a fake noodle?\n\n**An Impasta!** 🍝",
                x: centerX + 380,
                y: centerY + 150,
                model: "qwen-qwq-32b"
            },
            {
                text: "Why did the scarecrow win an award?\n\n**Because he was outstanding in his field!** 🌾",
                x: centerX,
                y: centerY + 300,
                model: "gemma2-9b-it"
            }
        ];

        const jokeNodes = jokes.map((joke, index) => ({
            id: (Date.now() + index + 1).toString(),
            type: "text",
            x: joke.x,
            y: joke.y,
            width: 360,
            height: 140,
            text: joke.text,
            fontSize: 14,
            isSelected: false,
            manuallyResized: false,
            maxHeight: 400,
            contentHeight: 140,
            scrollY: 0,
            generatedByModel: joke.model,
            // Per-node generation states
            isGeneratingAI: false,
            isGeneratingImage: false,
            isGeneratingVideo: false,
            isGeneratingContext: false,
            isGeneratingReference: false,
            isUploadingImage: false
        }));

        const connections = jokeNodes.map(jokeNode => ({
            id: `conn_${mainNode.id}_${jokeNode.id}`,
            fromNode: mainNode.id.toString(),
            toNode: jokeNode.id.toString()
        }));

        this.nodes = [mainNode, ...jokeNodes];
        this.connections = connections;
        this.rebuildSpatialGrid();
    }
    
    // Spatial grid for performance
    addNodeToGrid(node) {
        const startX = Math.floor(node.x / this.gridSize);
        const endX = Math.floor((node.x + node.width) / this.gridSize);
        const startY = Math.floor(node.y / this.gridSize);
        const endY = Math.floor((node.y + node.height) / this.gridSize);

        for (let x = startX; x <= endX; x++) {
            for (let y = startY; y <= endY; y++) {
                const key = `${x},${y}`;
                if (!this.spatialGrid.has(key)) {
                    this.spatialGrid.set(key, new Set());
                }
                this.spatialGrid.get(key).add(node);
            }
        }
    }
    
    removeNodeFromGrid(node) {
        for (const [key, nodes] of this.spatialGrid.entries()) {
            nodes.delete(node);
            if (nodes.size === 0) {
                this.spatialGrid.delete(key);
            }
        }
    }
    
    rebuildSpatialGrid() {
        this.spatialGrid.clear();
        this.nodes.forEach(node => this.addNodeToGrid(node));
    }
    
    getNodeAtPoint(x, y) {
        const key = `${Math.floor(x / this.gridSize)},${Math.floor(y / this.gridSize)}`;
        const candidates = this.spatialGrid.get(key);
        if (!candidates) return null;

        const candidateArray = Array.from(candidates);
        for (let i = candidateArray.length - 1; i >= 0; i--) {
            const node = candidateArray[i];
            if (x >= node.x && x <= node.x + node.width &&
                y >= node.y && y <= node.y + node.height) {
                return node;
            }
        }
        return null;
    }
} 


---
File: /infinite_canvas_v5/src/InfiniteCanvasSimple.js
---

// InfiniteCanvasSimple.js - Main class that coordinates all modules
import { CanvasState } from './CanvasState.js';
import { AIManager } from './AIManager.js';
import { UIManager } from './UIManager.js';
import { InputHandler } from './InputHandler.js';
import { renderCanvas } from './canvasRenderer.js';

export class InfiniteCanvas {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        // Initialize modules in correct order
        this.canvasState = new CanvasState();
        this.uiManager = new UIManager(this.canvasState);
        this.aiManager = new AIManager(this.canvasState, this.uiManager);
        this.inputHandler = new InputHandler(this.canvasState, this.uiManager, this.canvas, this.ctx);
        
        // Set up cross-references
        this.uiManager.setAIManager(this.aiManager);
        
        // Initialize the application
        this.setupCanvas();
        this.setupEventListeners();
        this.uiManager.setupUI();
        
        // Load saved data
        this.canvasState.loadFromLocalStorage();
        this.canvasState.saveState();
        
        // Start render loop
        this.startRenderLoop();
        
        // Update UI state
        this.uiManager.updateUndoRedoButtons();
        this.uiManager.updateModelSelectorUI();
        
        console.log('🚀 InfiniteCanvas initialized with modular architecture');
    }
    
    setupCanvas() {
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    }
    
    resizeCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
    }
    
    setupEventListeners() {
        // UI button events
        document.getElementById('configureBtn').addEventListener('click', () => {
            this.uiManager.showApiKeyModal();
        });
        
        document.getElementById('generateIdeasBtn').addEventListener('click', () => {
            this.aiManager.generateAI();
        });
        
        document.getElementById('expandContentBtn').addEventListener('click', () => {
            this.uiManager.showContentModal();
        });
        
        document.getElementById('generateImageBtn').addEventListener('click', () => {
            this.aiManager.generateImage();
        });
        
        document.getElementById('generateReferenceBtn').addEventListener('click', () => {
            this.aiManager.generateWithReference();
        });
        
        const uploadImageBtn = document.getElementById('uploadImageBtn');
        if (uploadImageBtn) {
            uploadImageBtn.addEventListener('click', () => {
                this.aiManager.uploadImage();
            });
        }
        
        document.getElementById('contextImageBtn').addEventListener('click', () => {
            this.aiManager.contextImage();
        });
        
        document.getElementById('generateVideoBtn').addEventListener('click', () => {
            this.aiManager.generateVideo();
        });
        
        // Canvas control buttons
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            this.inputHandler.zoom(1.2);
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            this.inputHandler.zoom(0.8);
        });
        
        document.getElementById('resetViewBtn').addEventListener('click', () => {
            this.inputHandler.resetView();
        });
        
        document.getElementById('fontSizeIncreaseBtn').addEventListener('click', () => {
            this.inputHandler.increaseFontSize();
        });
        
        document.getElementById('fontSizeDecreaseBtn').addEventListener('click', () => {
            this.inputHandler.decreaseFontSize();
        });
        
        // Undo/Redo buttons
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (this.canvasState.undo()) {
                this.uiManager.updateUndoRedoButtons();
                this.uiManager.showNotification('Undone', 'info', 1000);
            }
        });
        
        document.getElementById('redoBtn').addEventListener('click', () => {
            if (this.canvasState.redo()) {
                this.uiManager.updateUndoRedoButtons();
                this.uiManager.showNotification('Redone', 'info', 1000);
            }
        });
        
        // Import file input
        const importFileInput = document.getElementById('importFileInput');
        if (importFileInput) {
            importFileInput.addEventListener('change', (e) => {
                this.handleFileImport(e);
            });
        }
        
        // Upload image input
        const uploadImageInput = document.getElementById('uploadImageInput');
        if (uploadImageInput) {
            uploadImageInput.addEventListener('change', (e) => {
                this.aiManager.handleImageUpload(e);
            });
        }
    }
    
    handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.includes('json') && !file.name.toLowerCase().endsWith('.json')) {
            this.uiManager.showNotification('Please select a valid JSON file', 'error');
            return;
        }

        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            this.uiManager.showNotification('File is too large. Maximum size is 10MB', 'error');
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                
                if (!data || typeof data !== 'object') {
                    throw new Error('Invalid data format - not an object');
                }

                if (!Array.isArray(data.nodes)) {
                    throw new Error('Invalid or missing nodes data - nodes must be an array');
                }

                if (!Array.isArray(data.connections)) {
                    throw new Error('Invalid or missing connections data - connections must be an array');
                }
                
                // Save current state for undo
                this.canvasState.saveState();
                
                // Load the data
                this.canvasState.nodes = data.nodes || [];
                this.canvasState.connections = data.connections || [];
                
                // Reset view state if provided
                if (typeof data.offsetX === 'number') this.canvasState.offsetX = data.offsetX;
                if (typeof data.offsetY === 'number') this.canvasState.offsetY = data.offsetY;
                if (typeof data.scale === 'number') this.canvasState.scale = data.scale;
                if (typeof data.globalFontSize === 'number') this.canvasState.globalFontSize = data.globalFontSize;
                
                // Validate and fix data
                this.validateAndFixNodes();
                this.validateAndFixConnections();
                
                this.canvasState.clearSelection();
                this.canvasState.rebuildSpatialGrid();
                this.canvasState.saveToLocalStorage();
                this.uiManager.updateUndoRedoButtons();
                
                const nodeCount = this.canvasState.nodes.length;
                const connectionCount = this.canvasState.connections.length;
                this.uiManager.showNotification(
                    `Canvas imported successfully! Loaded ${nodeCount} nodes and ${connectionCount} connections.`,
                    'success'
                );
            } catch (error) {
                console.error('Import error:', error);
                this.uiManager.showNotification('Import failed: ' + error.message, 'error');
            }
        };
        
        reader.onerror = () => {
            this.uiManager.showNotification('Error reading file', 'error');
        };
        
        reader.readAsText(file);
        event.target.value = '';
    }
    
    validateAndFixNodes() {
        this.canvasState.nodes = this.canvasState.nodes.filter(node => {
            if (!node.id || typeof node.text !== 'string') {
                console.warn('Removing invalid node:', node);
                return false;
            }

            node.x = typeof node.x === 'number' ? node.x : 0;
            node.y = typeof node.y === 'number' ? node.y : 0;
            node.width = typeof node.width === 'number' ? node.width : 360;
            node.height = typeof node.height === 'number' ? node.height : 140;
            node.fontSize = typeof node.fontSize === 'number' ? node.fontSize : this.canvasState.globalFontSize;
            node.isSelected = false;

            return true;
        });

        this.canvasState.selectedNodes = [];
    }

    validateAndFixConnections() {
        const validNodeIds = new Set(this.canvasState.nodes.map(node => node.id));

        this.canvasState.connections = this.canvasState.connections.filter(connection => {
            if (!connection.fromNode || !connection.toNode) {
                console.warn('Removing connection with missing fromNode/toNode:', connection);
                return false;
            }

            if (!validNodeIds.has(connection.fromNode) || !validNodeIds.has(connection.toNode)) {
                console.warn('Removing connection with invalid node references:', connection);
                return false;
            }

            return true;
        });
    }
    
    startRenderLoop() {
        const render = () => {
            renderCanvas(
                this.ctx, 
                this.canvas, 
                this.canvasState, 
                this.inputHandler,
                this.uiManager
            );
            requestAnimationFrame(render);
        };
        render();
    }
    
    // Public API methods for external use
    createNode(text, x, y) {
        return this.canvasState.createNode(text, x, y);
    }
    
    deleteNode(node) {
        this.canvasState.deleteSelectedNodes();
    }
    
    selectNode(node) {
        this.canvasState.selectNodes(node);
    }
    
    clearSelection() {
        this.canvasState.clearSelection();
    }
    
    exportData() {
        return {
            nodes: this.canvasState.nodes,
            connections: this.canvasState.connections,
            exportDate: new Date().toISOString()
        };
    }
    
    importData(data) {
        if (data.nodes && Array.isArray(data.nodes)) {
            this.canvasState.saveState();
            this.canvasState.nodes = data.nodes;
            this.canvasState.connections = data.connections || [];
            this.canvasState.clearSelection();
            this.canvasState.rebuildSpatialGrid();
            this.canvasState.saveToLocalStorage();
            return true;
        }
        return false;
    }
} 


---
File: /infinite_canvas_v5/src/InputHandler.js
---

// InputHandler.js - Handles all mouse and keyboard interactions
import { 
    getConnectionPointAt, 
    getConnectionAtPoint, 
    getResizeHandleAt 
} from './canvasRenderer.js';
import { calculateMarkdownHeight } from './markdownParser.js';

export class InputHandler {
    constructor(canvasState, uiManager, canvas, ctx) {
        this.canvasState = canvasState;
        this.uiManager = uiManager;
        this.canvas = canvas;
        this.ctx = ctx;
        
        // Interaction state
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.dragTarget = null;
        this.isConnecting = false;
        this.connectionStart = null;
        this.connectionStartPoint = null;
        this.hoveredNode = null;
        this.isResizing = false;
        this.resizeHandle = null;
        this.resizeTarget = null;
        this.isSelecting = false;
        this.selectionStart = { x: 0, y: 0 };
        this.selectionEnd = { x: 0, y: 0 };
        this.isPanning = false;
        this.spacePressed = false;
        this.lastMouseX = canvas.width / 2;
        this.lastMouseY = canvas.height / 2;
        
        // Node editing
        this.editingNode = null;
        this.editInput = null;
        this.editingMediaName = false;
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Canvas mouse events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
        this.canvas.addEventListener('dblclick', (e) => this.onDoubleClick(e));
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Keyboard events
        document.addEventListener('keydown', (e) => this.onKeyDown(e));
        document.addEventListener('keyup', (e) => this.onKeyUp(e));
        document.addEventListener('paste', (e) => this.onPaste(e));
    }
    
    // Mouse event handlers
    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        this.lastMouseX = mouseX;
        this.lastMouseY = mouseY;

        const canvasX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
        const canvasY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

        // Handle right mouse button or space+left click for panning
        if (e.button === 2 || (e.button === 0 && this.spacePressed)) {
            this.isPanning = true;
            this.isDragging = true;
            this.dragStartX = mouseX;
            this.dragStartY = mouseY;
            this.dragTarget = 'canvas';
            this.canvas.style.cursor = 'grabbing';
            return;
        }

        if (e.button !== 0) return;

        // Check for connection click
        const clickedConnection = getConnectionAtPoint(canvasX, canvasY, this.canvasState.connections, this.canvasState.nodes);
        if (clickedConnection) {
            this.canvasState.clearSelection();
            this.canvasState.selectedConnection = clickedConnection;
            return;
        }

        // Check for node click
        const clickedNode = this.getNodeAtPointWithExtendedArea(canvasX, canvasY);

        if (clickedNode) {
            // Check for connection point first (these should work anywhere on the node boundary)
            const connectionPoint = getConnectionPointAt(clickedNode, canvasX, canvasY);
            if (connectionPoint) {
                this.isConnecting = true;
                this.connectionStart = clickedNode;
                this.connectionStartPoint = connectionPoint;
                this.canvas.style.cursor = 'crosshair';
                return;
            }

            // For media reference nodes, only allow other interactions in header area
            if (clickedNode.isMediaReference && !this.isInMediaNodeHeader(clickedNode, canvasX, canvasY)) {
                // Click is in the media content area (iframe/image), don't interfere with other interactions
                return;
            }

            // Check for resize handle
            let resizeHandle = null;
            if (clickedNode.isSelected) {
                resizeHandle = getResizeHandleAt(clickedNode, canvasX, canvasY);
            }

            if (!resizeHandle) {
                resizeHandle = this.getBorderResizeHandle(clickedNode, canvasX, canvasY);
            }

            if (resizeHandle) {
                if (this.canvasState.selectedNodes.length > 1) {
                    this.canvasState.selectNodes(clickedNode);
                } else if (!clickedNode.isSelected) {
                    this.canvasState.selectNodes(clickedNode);
                }
                this.isResizing = true;
                this.resizeHandle = resizeHandle;
                this.resizeTarget = clickedNode;
                this.setCursorForResize(resizeHandle);
                this.dragStartX = mouseX;
                this.dragStartY = mouseY;
                return;
            } else {
                // Handle multi-selection
                if (e.ctrlKey || e.metaKey) {
                    if (clickedNode.isSelected) {
                        this.canvasState.removeFromSelection(clickedNode);
                    } else {
                        this.canvasState.addToSelection(clickedNode);
                    }
                } else {
                    if (!clickedNode.isSelected) {
                        this.canvasState.selectNodes(clickedNode);
                    }
                }

                this.dragTarget = this.canvasState.selectedNodes.length > 1 ? 'selectedNodes' : clickedNode;
            }
        } else {
            // Clicked on empty space
            if (!(e.ctrlKey || e.metaKey)) {
                this.canvasState.clearSelection();
            } else {
                this.canvasState.selectedConnection = null;
            }

            if (!this.spacePressed) {
                this.isSelecting = true;
                this.selectionStart = { x: canvasX, y: canvasY };
                this.selectionEnd = { x: canvasX, y: canvasY };
            }
        }

        if (!this.isConnecting && !this.isResizing && !this.isSelecting) {
            this.isDragging = true;
            this.dragStartX = mouseX;
            this.dragStartY = mouseY;

            if (this.dragTarget === 'canvas') {
                this.canvas.style.cursor = 'grabbing';
            }
        } else if (this.isSelecting) {
            this.canvas.style.cursor = 'crosshair';
        } else if (!this.isConnecting && !this.isResizing) {
            this.isDragging = true;
            this.dragStartX = mouseX;
            this.dragStartY = mouseY;
        }

        this.uiManager.updateGenerateIdeasTooltip();
        this.uiManager.updateSelectionStatus();
    }
    
    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        this.lastMouseX = mouseX;
        this.lastMouseY = mouseY;
        
        const canvasX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
        const canvasY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;
        
        // Update cursor
        if (!this.isDragging && !this.isConnecting && !this.isResizing) {
            if (this.spacePressed) {
                this.canvas.style.cursor = 'grab';
            } else {
                const hoveredNode = this.getNodeAtPointWithExtendedArea(canvasX, canvasY);

                if (this.hoveredNode !== hoveredNode) {
                    this.hoveredNode = hoveredNode;
                }

                if (hoveredNode) {
                    const connectionPoint = getConnectionPointAt(hoveredNode, canvasX, canvasY);
                    if (connectionPoint) {
                        this.canvas.style.cursor = 'crosshair';
                    } else {
                        let resizeHandle = null;
                        if (hoveredNode.isSelected) {
                            resizeHandle = getResizeHandleAt(hoveredNode, canvasX, canvasY);
                        }

                        if (!resizeHandle) {
                            resizeHandle = this.getBorderResizeHandle(hoveredNode, canvasX, canvasY);
                        }

                        if (resizeHandle) {
                            this.setCursorForResize(resizeHandle);
                        } else {
                            this.canvas.style.cursor = 'grab';
                        }
                    }
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }
        }
        
        if (this.isSelecting) {
            this.selectionEnd = { x: canvasX, y: canvasY };
            return;
        }

        if (this.isConnecting) {
            return;
        }

        if (this.isResizing) {
            const deltaX = mouseX - this.dragStartX;
            const deltaY = mouseY - this.dragStartY;

            this.resizeTarget.manuallyResized = true;

            const minWidth = 60;
            const minHeight = 40;
            const scaledDeltaX = deltaX / this.canvasState.scale;
            const scaledDeltaY = deltaY / this.canvasState.scale;

            switch(this.resizeHandle) {
                case 'top':
                    const newHeightTop = this.resizeTarget.height - scaledDeltaY;
                    if (newHeightTop >= minHeight) {
                        this.resizeTarget.y += scaledDeltaY;
                        this.resizeTarget.height = newHeightTop;
                    }
                    break;
                case 'bottom':
                    this.resizeTarget.height = Math.max(minHeight, this.resizeTarget.height + scaledDeltaY);
                    break;
                case 'left':
                    const newWidthLeft = this.resizeTarget.width - scaledDeltaX;
                    if (newWidthLeft >= minWidth) {
                        this.resizeTarget.x += scaledDeltaX;
                        this.resizeTarget.width = newWidthLeft;
                    }
                    break;
                case 'right':
                    this.resizeTarget.width = Math.max(minWidth, this.resizeTarget.width + scaledDeltaX);
                    break;
                case 'top-left':
                    const newWidthTL = this.resizeTarget.width - scaledDeltaX;
                    const newHeightTL = this.resizeTarget.height - scaledDeltaY;
                    if (newWidthTL >= minWidth && newHeightTL >= minHeight) {
                        this.resizeTarget.x += scaledDeltaX;
                        this.resizeTarget.y += scaledDeltaY;
                        this.resizeTarget.width = newWidthTL;
                        this.resizeTarget.height = newHeightTL;
                    }
                    break;
                case 'top-right':
                    const newHeightTR = this.resizeTarget.height - scaledDeltaY;
                    if (newHeightTR >= minHeight) {
                        this.resizeTarget.y += scaledDeltaY;
                        this.resizeTarget.height = newHeightTR;
                    }
                    this.resizeTarget.width = Math.max(minWidth, this.resizeTarget.width + scaledDeltaX);
                    break;
                case 'bottom-left':
                    const newWidthBL = this.resizeTarget.width - scaledDeltaX;
                    if (newWidthBL >= minWidth) {
                        this.resizeTarget.x += scaledDeltaX;
                        this.resizeTarget.width = newWidthBL;
                    }
                    this.resizeTarget.height = Math.max(minHeight, this.resizeTarget.height + scaledDeltaY);
                    break;
                case 'bottom-right':
                    this.resizeTarget.width = Math.max(minWidth, this.resizeTarget.width + scaledDeltaX);
                    this.resizeTarget.height = Math.max(minHeight, this.resizeTarget.height + scaledDeltaY);
                    break;
            }

            this.dragStartX = mouseX;
            this.dragStartY = mouseY;
            return;
        }

        if (!this.isDragging) return;

        const deltaX = mouseX - this.dragStartX;
        const deltaY = mouseY - this.dragStartY;

        if (this.dragTarget === 'canvas') {
            this.canvasState.offsetX += deltaX;
            this.canvasState.offsetY += deltaY;
        } else if (this.dragTarget === 'selectedNodes') {
            const scaledDeltaX = deltaX / this.canvasState.scale;
            const scaledDeltaY = deltaY / this.canvasState.scale;
            this.canvasState.selectedNodes.forEach(node => {
                node.x += scaledDeltaX;
                node.y += scaledDeltaY;
                this.canvasState.removeNodeFromGrid(node);
                this.canvasState.addNodeToGrid(node);
            });
        } else if (this.dragTarget && typeof this.dragTarget === 'object') {
            this.canvasState.removeNodeFromGrid(this.dragTarget);
            this.dragTarget.x += deltaX / this.canvasState.scale;
            this.dragTarget.y += deltaY / this.canvasState.scale;
            this.canvasState.addNodeToGrid(this.dragTarget);
        }

        this.dragStartX = mouseX;
        this.dragStartY = mouseY;
    }
    
    onMouseUp(e) {
        if (this.isSelecting) {
            this.isSelecting = false;

            const rect = {
                x: Math.min(this.selectionStart.x, this.selectionEnd.x),
                y: Math.min(this.selectionStart.y, this.selectionEnd.y),
                width: Math.abs(this.selectionEnd.x - this.selectionStart.x),
                height: Math.abs(this.selectionEnd.y - this.selectionStart.y)
            };

            const nodesInSelection = this.canvasState.nodes.filter(node => {
                return node.x < rect.x + rect.width &&
                       node.x + node.width > rect.x &&
                       node.y < rect.y + rect.height &&
                       node.y + node.height > rect.y;
            });

            if (e.ctrlKey || e.metaKey) {
                nodesInSelection.forEach(node => this.canvasState.addToSelection(node));
            } else {
                this.canvasState.selectNodes(nodesInSelection);
            }

            this.canvas.style.cursor = 'grab';
            this.uiManager.updateGenerateIdeasTooltip();
            this.uiManager.updateSelectionStatus();
            return;
        }

        if (this.isConnecting) {
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const canvasX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
            const canvasY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

            const targetNode = this.getNodeAtPointWithExtendedArea(canvasX, canvasY);

            if (targetNode && targetNode !== this.connectionStart) {
                this.canvasState.createConnection(this.connectionStart, targetNode);
            } else if (!targetNode) {
                const newNode = this.canvasState.createNode('New Node', canvasX - 200, canvasY - 30);
                this.canvasState.createConnection(this.connectionStart, newNode);
                this.canvasState.selectNodes(newNode);
                setTimeout(() => {
                    this.startEditingNode(newNode);
                }, 50);
            }

            this.isConnecting = false;
            this.connectionStart = null;
            this.connectionStartPoint = null;
            this.canvas.style.cursor = 'grab';
            this.canvasState.saveToLocalStorage();
            this.uiManager.updateUndoRedoButtons();
            return;
        }

        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            this.resizeTarget = null;
            this.canvas.style.cursor = 'grab';
            this.canvasState.saveToLocalStorage();
            this.uiManager.updateUndoRedoButtons();
            return;
        }

        this.isDragging = false;
        this.isPanning = false;
        this.dragTarget = null;
        this.canvas.style.cursor = this.spacePressed ? 'grab' : 'default';

        if (this.dragTarget !== 'canvas') {
            this.canvasState.saveToLocalStorage();
        }

        if ((this.isDragging && this.dragTarget !== 'canvas' && !this.isPanning) || this.isResizing) {
            this.canvasState.saveState();
        }
        
        if (this.isConnecting && this.hoveredNode && this.connectionStart.id !== this.hoveredNode.id) {
            this.canvasState.createConnection(this.connectionStart, this.hoveredNode);
        }

        this.uiManager.updateUndoRedoButtons();
        this.editingNode = null;
    }
    
    onWheel(e) {
        e.preventDefault();

        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const canvasX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
        const canvasY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

        // Check for node scrolling
        const hoveredNode = this.canvasState.getNodeAtPoint(canvasX, canvasY);
        if (hoveredNode && hoveredNode.isSelected && hoveredNode.contentHeight > hoveredNode.height) {
            const scrollSensitivity = 20;
            const maxScrollY = hoveredNode.contentHeight - hoveredNode.height;

            if (hoveredNode.scrollY === undefined) {
                hoveredNode.scrollY = 0;
            }

            hoveredNode.scrollY = Math.max(0, Math.min(maxScrollY, hoveredNode.scrollY + e.deltaY * scrollSensitivity / 100));
            return;
        }

        // Detect trackpad vs mouse wheel
        const isTrackpad = Math.abs(e.deltaY) < 50 || Math.abs(e.deltaX) > 0;

        // Handle trackpad pinch-to-zoom
        if (e.ctrlKey && isTrackpad) {
            const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
            const newScale = Math.max(0.1, Math.min(3.0, this.canvasState.scale * zoomFactor));

            const beforeZoomX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
            const beforeZoomY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

            this.canvasState.scale = newScale;

            const afterZoomX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
            const afterZoomY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

            this.canvasState.offsetX += (afterZoomX - beforeZoomX) * this.canvasState.scale;
            this.canvasState.offsetY += (afterZoomY - beforeZoomY) * this.canvasState.scale;
            return;
        }

        // Handle trackpad two-finger scrolling for panning
        if (isTrackpad && !e.ctrlKey && !e.metaKey) {
            const panSensitivity = 1.0;
            this.canvasState.offsetX -= e.deltaX * panSensitivity;
            this.canvasState.offsetY -= e.deltaY * panSensitivity;
            return;
        }

        // Handle zoom
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(0.1, Math.min(3.0, this.canvasState.scale * zoomFactor));

        const beforeZoomX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
        const beforeZoomY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

        this.canvasState.scale = newScale;

        const afterZoomX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
        const afterZoomY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;

        this.canvasState.offsetX += (afterZoomX - beforeZoomX) * this.canvasState.scale;
        this.canvasState.offsetY += (afterZoomY - beforeZoomY) * this.canvasState.scale;
    }
    
    onDoubleClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const canvasX = (mouseX - this.canvasState.offsetX) / this.canvasState.scale;
        const canvasY = (mouseY - this.canvasState.offsetY) / this.canvasState.scale;
        
        const clickedNode = this.getNodeAtPointWithExtendedArea(canvasX, canvasY);
        
        if (clickedNode) {
            // Check if it's a media reference node and we're clicking in the header
            if (clickedNode.isMediaReference && this.isInMediaNodeHeader(clickedNode, canvasX, canvasY)) {
                this.startEditingMediaNodeName(clickedNode);
            } else if (!clickedNode.isMediaReference) {
                // Regular text node editing
                this.startEditingNode(clickedNode);
            }
        } else {
            const newNode = this.canvasState.createNode('New Node', canvasX - 100, canvasY - 30);
            setTimeout(() => {
                this.startEditingNode(newNode);
            }, 50);
        }
    }
    
    // Keyboard event handlers
    onKeyDown(e) {
        if (e.key === ' ' && !this.spacePressed) {
            if (this.editingNode || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            e.preventDefault();
            this.spacePressed = true;
            if (!this.isDragging) {
                this.canvas.style.cursor = 'grab';
            }
            return;
        }

        if (this.editingNode || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
            return;
        }

        switch(e.key) {
            case 'Delete':
            case 'Backspace':
                if (this.canvasState.selectedNodes.length > 0) {
                    this.canvasState.deleteSelectedNodes();
                } else if (this.canvasState.selectedConnection) {
                    this.deleteSelectedConnection();
                }
                this.uiManager.updateUndoRedoButtons();
                break;
            case 'a':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.canvasState.selectNodes(this.canvasState.nodes);
                }
                break;
            case 'c':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.canvasState.copySelectedNodes();
                }
                break;
            case 'v':
                if (e.ctrlKey || e.metaKey) {
                    // Let the default browser paste action continue so the 'paste' event fires.
                    // First, attempt to paste internal canvas nodes (duplicates) if any exist.
                    this.canvasState.pasteNodes();
                    this.uiManager.updateUndoRedoButtons();
                }
                break;
            case 'z':
                if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
                    e.preventDefault();
                    this.canvasState.redo();
                    this.uiManager.updateUndoRedoButtons();
                } else if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.canvasState.undo();
                    this.uiManager.updateUndoRedoButtons();
                }
                break;
            case 'y':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.canvasState.redo();
                    this.uiManager.updateUndoRedoButtons();
                }
                break;
        }

        this.uiManager.updateGenerateIdeasTooltip();
        this.uiManager.updateSelectionStatus();
    }

    onKeyUp(e) {
        if (e.key === ' ') {
            this.spacePressed = false;
            if (!this.isDragging) {
                this.canvas.style.cursor = 'default';
            }
        }
    }
    
    // Helper methods
    getNodeAtPointWithExtendedArea(x, y) {
        const hoverExtension = 24;

        let foundNode = this.canvasState.getNodeAtPoint(x, y);
        if (foundNode) {
            return foundNode;
        }

        for (let i = this.canvasState.nodes.length - 1; i >= 0; i--) {
            const node = this.canvasState.nodes[i];

            if (x >= node.x - hoverExtension && x <= node.x + node.width + hoverExtension &&
                y >= node.y - hoverExtension && y <= node.y + node.height + hoverExtension) {
                return node;
            }
        }

        return null;
    }

    // Check if click is in the draggable header area of a media reference node
    isInMediaNodeHeader(node, x, y) {
        if (!node.isMediaReference || !node._headerHeight) return false;
        
        return x >= node.x && x <= node.x + node.width &&
               y >= node.y && y <= node.y + node._headerHeight;
    }

    getBorderResizeHandle(node, x, y) {
        const connectionPoint = getConnectionPointAt(node, x, y);
        if (connectionPoint) {
            return null;
        }

        const borderTolerance = 24;
        const cornerSize = 40;

        const nodeLeft = node.x;
        const nodeRight = node.x + node.width;
        const nodeTop = node.y;
        const nodeBottom = node.y + node.height;

        const nearLeft = Math.abs(x - nodeLeft) <= borderTolerance;
        const nearRight = Math.abs(x - nodeRight) <= borderTolerance;
        const nearTop = Math.abs(y - nodeTop) <= borderTolerance;
        const nearBottom = Math.abs(y - nodeBottom) <= borderTolerance;

        const withinHorizontalBounds = x >= nodeLeft - borderTolerance && x <= nodeRight + borderTolerance;
        const withinVerticalBounds = y >= nodeTop - borderTolerance && y <= nodeBottom + borderTolerance;

        // Corner resize handles
        if (nearTop && nearLeft &&
            x >= nodeLeft - borderTolerance && x <= nodeLeft + cornerSize &&
            y >= nodeTop - borderTolerance && y <= nodeTop + cornerSize) {
            return 'top-left';
        }

        if (nearTop && nearRight &&
            x >= nodeRight - cornerSize && x <= nodeRight + borderTolerance &&
            y >= nodeTop - borderTolerance && y <= nodeTop + cornerSize) {
            return 'top-right';
        }

        if (nearBottom && nearLeft &&
            x >= nodeLeft - borderTolerance && x <= nodeLeft + cornerSize &&
            y >= nodeBottom - cornerSize && y <= nodeBottom + borderTolerance) {
            return 'bottom-left';
        }

        if (nearBottom && nearRight &&
            x >= nodeRight - cornerSize && x <= nodeRight + borderTolerance &&
            y >= nodeBottom - cornerSize && y <= nodeBottom + borderTolerance) {
            return 'bottom-right';
        }

        // Edge resize handles
        if (nearTop && withinHorizontalBounds &&
            x > nodeLeft + cornerSize && x < nodeRight - cornerSize) {
            return 'top';
        }

        if (nearBottom && withinHorizontalBounds &&
            x > nodeLeft + cornerSize && x < nodeRight - cornerSize) {
            return 'bottom';
        }

        if (nearLeft && withinVerticalBounds &&
            y > nodeTop + cornerSize && y < nodeBottom - cornerSize) {
            return 'left';
        }

        if (nearRight && withinVerticalBounds &&
            y > nodeTop + cornerSize && y < nodeBottom - cornerSize) {
            return 'right';
        }

        return null;
    }

    setCursorForResize(handle) {
        const nsResizeCursor = `url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cg%3E%3Cpath d='M8 2l-2 2h1v8h-1l2 2 2-2h-1V4h1l-2-2z' stroke='white' stroke-width='3' fill='white'/%3E%3C/g%3E%3C/svg%3E"), ns-resize`;
        const ewResizeCursor = `url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cg%3E%3Cpath d='M2 8l2-2v1h8v-1l2 2-2 2v-1H4v1l-2-2z' stroke='white' stroke-width='3' fill='white'/%3E%3C/g%3E%3C/svg%3E"), ew-resize`;
        const nwseResizeCursor = `url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cg%3E%3Cpath d='M3 3l2 0v1l6 6h1v2l-2-2h-1L3 4v-1z' stroke='white' stroke-width='3' fill='black'/%3E%3Cpath d='M13 13l-2 0v-1l-6-6h-1v-2l2 2h1l6 6v1z' stroke='white' stroke-width='2' fill='black'/%3E%3C/g%3E%3C/svg%3E"), nw-resize`;
        const neswResizeCursor = `url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cg%3E%3Cpath d='M13 3l-2 0v1l-6 6h-1v2l2-2h1l6-6v-1z' stroke='white' stroke-width='3' fill='black'/%3E%3Cpath d='M3 13l2 0v-1l6-6h1v-2l-2 2h-1L3 12v1z' stroke='white' stroke-width='2' fill='black'/%3E%3C/g%3E%3C/svg%3E"), ne-resize`;

        switch(handle) {
            case 'top':
            case 'bottom':
                this.canvas.style.cursor = nsResizeCursor;
                break;
            case 'left':
            case 'right':
                this.canvas.style.cursor = ewResizeCursor;
                break;
            case 'top-left':
            case 'bottom-right':
                this.canvas.style.cursor = nwseResizeCursor;
                break;
            case 'top-right':
            case 'bottom-left':
                this.canvas.style.cursor = neswResizeCursor;
                break;
            default:
                this.canvas.style.cursor = 'default';
        }
    }

    deleteSelectedConnection() {
        if (this.canvasState.selectedConnection) {
            const connId = this.canvasState.selectedConnection.id;
            this.canvasState.connections = this.canvasState.connections.filter(c => c.id !== connId);
            this.canvasState.selectedConnection = null;
            this.canvasState.saveState();
            this.uiManager.updateUndoRedoButtons();
        }
    }

    // Node editing
    startEditingNode(node) {
        this.editingNode = node;
        
        this.editInput = document.createElement('textarea');
        this.editInput.value = node.text;
        this.editInput.className = 'node-input';
        
        const rect = this.canvas.getBoundingClientRect();
        const x = rect.left + (node.x * this.canvasState.scale) + this.canvasState.offsetX;
        const y = rect.top + (node.y * this.canvasState.scale) + this.canvasState.offsetY;

        this.editInput.style.left = x + 'px';
        this.editInput.style.top = y + 'px';
        this.editInput.style.width = (node.width * this.canvasState.scale) + 'px';
        this.editInput.style.height = (node.height * this.canvasState.scale) + 'px';

        const nodeFontSize = node.fontSize || this.canvasState.globalFontSize;
        this.editInput.style.fontSize = (nodeFontSize * this.canvasState.scale) + 'px';
        
        document.body.appendChild(this.editInput);
        this.editInput.focus();
        this.editInput.select();
        
        this.editInput.addEventListener('blur', () => this.finishEditingNode());
        this.editInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.finishEditingNode();
            }
        });
    }
    
    finishEditingNode() {
        if (this.editingNode && this.editInput) {
            if (this.editingMediaName) {
                this.finishEditingMediaNodeName();
                return;
            }
            
            const newText = this.editInput.value;
            if (this.editingNode.text !== newText) {
                this.editingNode.text = newText;
                this.editingNode.height = calculateMarkdownHeight(this.ctx, newText, this.editingNode.width, this.editingNode.fontSize);
                this.canvasState.saveState();
                this.uiManager.updateUndoRedoButtons();
            }

            document.body.removeChild(this.editInput);
            this.editInput = null;
            this.editingNode = null;
        }
    }

    finishEditingMediaNodeName() {
        if (this.editingNode && this.editInput && this.editingMediaName) {
            const newName = this.editInput.value.trim();
            if (this.editingNode.name !== newName) {
                this.canvasState.saveState();
                this.editingNode.name = newName;
                this.canvasState.saveToLocalStorage();
                this.uiManager.updateUndoRedoButtons();
            }

            document.body.removeChild(this.editInput);
            this.editInput = null;
            this.editingNode = null;
            this.editingMediaName = false;
        }
    }

    cancelEditingMediaNodeName() {
        if (this.editInput) {
            document.body.removeChild(this.editInput);
            this.editInput = null;
            this.editingNode = null;
            this.editingMediaName = false;
        }
    }

    startEditingMediaNodeName(node) {
        this.editingNode = node;
        this.editingMediaName = true;
        
        this.editInput = document.createElement('input');
        this.editInput.type = 'text';
        this.editInput.value = node.name || '';
        this.editInput.className = 'media-name-input';
        this.editInput.placeholder = 'Enter image name...';
        
        const rect = this.canvas.getBoundingClientRect();
        const x = rect.left + (node.x * this.canvasState.scale) + this.canvasState.offsetX;
        const y = rect.top + (node.y * this.canvasState.scale) + this.canvasState.offsetY;

        this.editInput.style.left = (x + 8) + 'px';
        this.editInput.style.top = (y + 5) + 'px';
        this.editInput.style.width = ((node.width - 16) * this.canvasState.scale) + 'px';
        this.editInput.style.height = '20px';
        this.editInput.style.fontSize = '12px';
        this.editInput.style.fontWeight = 'bold';
        this.editInput.style.background = '#374151';
        this.editInput.style.color = '#e2e8f0';
        this.editInput.style.border = '1px solid #4299e1';
        this.editInput.style.borderRadius = '3px';
        this.editInput.style.padding = '2px 4px';
        
        document.body.appendChild(this.editInput);
        this.editInput.focus();
        this.editInput.select();
        
        this.editInput.addEventListener('blur', () => this.finishEditingMediaNodeName());
        this.editInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.finishEditingMediaNodeName();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                this.cancelEditingMediaNodeName();
            }
        });
    }

    // Canvas controls
    zoom(factor) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        const beforeZoomX = (centerX - this.canvasState.offsetX) / this.canvasState.scale;
        const beforeZoomY = (centerY - this.canvasState.offsetY) / this.canvasState.scale;
        
        this.canvasState.scale = Math.max(0.1, Math.min(3.0, this.canvasState.scale * factor));
        
        const afterZoomX = (centerX - this.canvasState.offsetX) / this.canvasState.scale;
        const afterZoomY = (centerY - this.canvasState.offsetY) / this.canvasState.scale;
        
        this.canvasState.offsetX += (afterZoomX - beforeZoomX) * this.canvasState.scale;
        this.canvasState.offsetY += (afterZoomY - beforeZoomY) * this.canvasState.scale;
    }

    resetView() {
        this.canvasState.resetView();
    }

    increaseFontSize() {
        const nodesToChange = this.canvasState.selectedNodes.length > 0 ? this.canvasState.selectedNodes : this.canvasState.nodes;
        nodesToChange.forEach(node => {
            node.fontSize = (node.fontSize || this.canvasState.globalFontSize) + 2;
            if (!node.manuallyResized) {
                node.height = calculateMarkdownHeight(this.ctx, node.text, node.width, node.fontSize);
            }
        });

        if (this.canvasState.selectedNodes.length === 0) {
            this.canvasState.globalFontSize += 2;
        }

        this.canvasState.saveState();
        this.uiManager.updateUndoRedoButtons();
    }

    decreaseFontSize() {
        const nodesToChange = this.canvasState.selectedNodes.length > 0 ? this.canvasState.selectedNodes : this.canvasState.nodes;
        nodesToChange.forEach(node => {
            node.fontSize = Math.max(8, (node.fontSize || this.canvasState.globalFontSize) - 2);
            if (!node.manuallyResized) {
                node.height = calculateMarkdownHeight(this.ctx, node.text, node.width, node.fontSize);
            }
        });

        if (this.canvasState.selectedNodes.length === 0) {
            this.canvasState.globalFontSize = Math.max(8, this.canvasState.globalFontSize - 2);
        }

        this.canvasState.saveState();
        this.uiManager.updateUndoRedoButtons();
    }

    // Handle clipboard paste for images / videos / URLs
    onPaste(e) {
        if (this.editingNode) {
            return;
        }

        // Ignore if currently typing inside an input or textarea
        const activeTag = document.activeElement.tagName;
        if (activeTag === 'INPUT' || activeTag === 'TEXTAREA') return;

        const clipboard = e.clipboardData;
        if (!clipboard) return;

        const items = clipboard.items || [];
        let handled = false;

        // Helper to convert current screen coords to canvas coords
        const getPasteCoords = () => {
            const canvasX = (this.lastMouseX - this.canvasState.offsetX) / this.canvasState.scale;
            const canvasY = (this.lastMouseY - this.canvasState.offsetY) / this.canvasState.scale;
            return { x: canvasX, y: canvasY };
        };

        // 1. First check for URLs in text (higher priority than files for web content)
        const textData = clipboard.getData('text');
        if (textData && !handled) {
            const trimmedUrl = textData.trim();
            
            // Check for YouTube URLs
            if (this.isYouTubeUrl(trimmedUrl)) {
                const { x, y } = getPasteCoords();
                this.createMediaNode(trimmedUrl, 'youtube', x, y);
                handled = true;
            }
            // Check for other video platform URLs
            else if (this.isVideoUrl(trimmedUrl)) {
                const { x, y } = getPasteCoords();
                this.createMediaNode(trimmedUrl, 'video', x, y);
                handled = true;
            }
            // Check for direct media file URLs
            else if (this.isDirectMediaUrl(trimmedUrl)) {
                const { x, y } = getPasteCoords();
                const isImage = /(png|jpe?g|gif|webp|bmp|svg)$/i.test(trimmedUrl.toLowerCase());
                this.createMediaNode(trimmedUrl, isImage ? 'image' : 'video', x, y);
                handled = true;
            }
        }

        // 2A. Handle pasted files via items (Chrome/Edge/Firefox) - only if no URL was handled
        if (!handled) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const file = item.getAsFile();
                    if (!file) continue;
                    if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
                        const url = URL.createObjectURL(file);
                        const { x, y } = getPasteCoords();
                        this.createMediaNode(url, file.type.startsWith('image/') ? 'image' : 'video', x, y, file);
                        handled = true;
                    }
                }
            }
        }

        // 2B. Fallback for clipboard.files (Safari) - only if no URL or file was handled
        if (!handled && clipboard.files && clipboard.files.length > 0) {
            Array.from(clipboard.files).forEach(file => {
                if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
                    const url = URL.createObjectURL(file);
                    const { x, y } = getPasteCoords();
                    this.createMediaNode(url, file.type.startsWith('image/') ? 'image' : 'video', x, y, file);
                    handled = true;
                }
            });
        }

        if (handled) {
            e.preventDefault();
        }
    }

    // Helper methods for URL detection
    isYouTubeUrl(url) {
        const youtubeRegex = /^https?:\/\/(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)/i;
        return youtubeRegex.test(url);
    }

    isVideoUrl(url) {
        // Common video platforms
        const videoSites = [
            'vimeo.com',
            'dailymotion.com',
            'twitch.tv',
            'tiktok.com',
            'instagram.com',
            'twitter.com',
            'x.com'
        ];
        
        try {
            const urlObj = new URL(url);
            return videoSites.some(site => urlObj.hostname.includes(site));
        } catch {
            return false;
        }
    }

    isDirectMediaUrl(url) {
        // Direct file URLs
        const mediaRegex = /\.(png|jpe?g|gif|webp|bmp|svg|mp4|webm|mov|ogg|m4v|avi|mkv)(\?.*)?$/i;
        return mediaRegex.test(url);
    }

    // Utility to create a minimal media reference node
    createMediaNode(url, mediaType, x, y, file = null) {
        // Store previously selected nodes (to potentially auto-connect)
        const previousSelection = [...this.canvasState.selectedNodes];

        const node = this.canvasState.createNode('', x, y, null);
        node.width = 320;
        node.height = mediaType === 'image' ? 240 : 270; // Increased video height to account for header
        node.isMediaReference = true;
        node.manuallyResized = true; // prevent auto resize
        node._headerHeight = 50; // Set header height for consistent UI across all media nodes

        if (mediaType === 'image') {
            node.generatedImageUrl = url;
        } else if (mediaType === 'youtube') {
            node.generatedVideoUrl = url;
            node.isYouTubeVideo = true;
            // Set custom dimensions for YouTube videos (accounting for header)
            node.width = 480;
            node.height = 320; // 270 (16:9 video) + 50 (header) = 320 total
        } else {
            node.generatedVideoUrl = url;
        }

        // Auto-connect to previously selected node if exactly one was selected
        if (previousSelection.length === 1) {
            this.canvasState.createConnection(previousSelection[0], node);
        }

        // Update spatial grid with new size
        this.canvasState.removeNodeFromGrid(node);
        this.canvasState.addNodeToGrid(node);

        // Select the newly created node so user can immediately move it
        this.canvasState.clearSelection();
        this.canvasState.selectNodes(node);

        // Save state for undo history (includes possible auto-connection)
        this.canvasState.saveState();
        
        // Save to localStorage to persist across page reloads
        this.canvasState.saveToLocalStorage();

        // If we pasted a local file image, upload it automatically so it gets a public URL
        if (mediaType === 'image' && file && url.startsWith('blob:')) {
            this.uiManager.showNotification('Uploading image…', 'info', 3000);
            this.uploadFileToLitterbox(file)
                .then(remoteUrl => {
                    node.generatedImageUrl = remoteUrl;
                    this.canvasState.saveToLocalStorage();
                    this.uiManager.showNotification('Image uploaded successfully!', 'success');
                })
                .catch(err => {
                    console.error('Image upload failed:', err);
                    this.uiManager.showNotification('Image upload failed: ' + err.message, 'error');
                });
        }

        if (this.uiManager && typeof this.uiManager.updateSelectionStatus === 'function') {
            this.uiManager.updateSelectionStatus();
        }
    }

    // Helper to upload an image file to Litterbox (72-hour temporary hosting)
    uploadFileToLitterbox(file) {
        return new Promise((resolve, reject) => {
            const formData = new FormData();
            formData.append('reqtype', 'fileupload');
            formData.append('time', '72h');
            formData.append('fileToUpload', file);

            const xhr = new XMLHttpRequest();
            xhr.onload = function () {
                if (xhr.status === 200) {
                    const response = xhr.responseText.trim();
                    if (response.startsWith('https://')) {
                        resolve(response);
                    } else {
                        reject(new Error('Invalid response from upload service: ' + response));
                    }
                } else {
                    reject(new Error(`Upload failed with status ${xhr.status}: ${xhr.statusText}`));
                }
            };
            xhr.onerror = function () {
                reject(new Error('Network error during upload'));
            };
            xhr.ontimeout = function () {
                reject(new Error('Upload timed out'));
            };
            xhr.timeout = 60000; // 1 min
            xhr.open('POST', 'https://litterbox.catbox.moe/resources/internals/api.php');
            xhr.send(formData);
        });
    }
} 


---
File: /infinite_canvas_v5/src/markdownParser.js
---

// Lightweight markdown parser optimized for canvas rendering
// Supports: headers, bold, italic, lists, code, and paragraphs

export function parseMarkdown(text, baseFontSize = 14) {
    if (!text || typeof text !== 'string') {
        return [{ type: 'text', content: '', fontSize: baseFontSize, fontWeight: 'normal', fontStyle: 'normal' }];
    }

    const lines = text.split('\n');
    const parsed = [];

    // Calculate scaled font sizes based on the base font size
    const scaleFactor = baseFontSize / 14; // 14 is the original default
    const spacingSize = Math.round(8 * scaleFactor);
    const h3Size = Math.round(16 * scaleFactor);
    const h2Size = Math.round(18 * scaleFactor);
    const h1Size = Math.round(20 * scaleFactor);

    lines.forEach((line, index) => {
        const trimmedLine = line.trim();

        // Skip empty lines but preserve spacing
        if (trimmedLine === '') {
            if (index < lines.length - 1) { // Don't add spacing for last empty line
                parsed.push({ type: 'spacing', content: '', fontSize: spacingSize, fontWeight: 'normal', fontStyle: 'normal' });
            }
            return;
        }

        // Headers
        if (trimmedLine.startsWith('### ')) {
            parsed.push({
                type: 'header',
                content: trimmedLine.slice(4),
                fontSize: h3Size,
                fontWeight: 'bold',
                fontStyle: 'normal',
                level: 3
            });
        } else if (trimmedLine.startsWith('## ')) {
            parsed.push({
                type: 'header',
                content: trimmedLine.slice(3),
                fontSize: h2Size,
                fontWeight: 'bold',
                fontStyle: 'normal',
                level: 2
            });
        } else if (trimmedLine.startsWith('# ')) {
            parsed.push({
                type: 'header',
                content: trimmedLine.slice(2),
                fontSize: h1Size,
                fontWeight: 'bold',
                fontStyle: 'normal',
                level: 1
            });
        }
        // Lists
        else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
            const content = trimmedLine.slice(2);
            const processedContent = processInlineFormatting(content);
            parsed.push({
                type: 'list',
                content: processedContent,
                fontSize: baseFontSize,
                fontWeight: 'normal',
                fontStyle: 'normal',
                bullet: '•'
            });
        }
        // Regular text with inline formatting
        else {
            const processedContent = processInlineFormatting(trimmedLine);
            parsed.push({
                type: 'text',
                content: processedContent,
                fontSize: baseFontSize,
                fontWeight: 'normal',
                fontStyle: 'normal'
            });
        }
    });

    return parsed.length > 0 ? parsed : [{ type: 'text', content: '', fontSize: baseFontSize, fontWeight: 'normal', fontStyle: 'normal' }];
}

// Process inline formatting like **bold**, *italic*, and `code`
function processInlineFormatting(text) {
    const segments = [];

    // Process formatting in order of precedence to avoid conflicts
    // 1. Code blocks first (highest precedence)
    // 2. Bold text (must come before italic to avoid conflicts)
    // 3. Italic text (lowest precedence)

    const formatRanges = [];

    // Find code blocks first
    let codeRegex = /`([^`]+)`/g;
    let match;
    while ((match = codeRegex.exec(text)) !== null) {
        formatRanges.push({
            start: match.index,
            end: match.index + match[0].length,
            content: match[1],
            type: 'code'
        });
    }

    // Find bold text (must come before italic)
    let boldRegex = /\*\*([^*]+)\*\*/g;
    while ((match = boldRegex.exec(text)) !== null) {
        // Check if this range overlaps with any existing ranges
        const overlaps = formatRanges.some(range =>
            (match.index < range.end && match.index + match[0].length > range.start)
        );
        if (!overlaps) {
            formatRanges.push({
                start: match.index,
                end: match.index + match[0].length,
                content: match[1],
                type: 'bold'
            });
        }
    }

    // Find italic text (lowest precedence) - make sure it's not part of bold text
    let italicRegex = /(?<!\*)\*([^*]+)\*(?!\*)/g;
    while ((match = italicRegex.exec(text)) !== null) {
        // Check if this range overlaps with any existing ranges
        const overlaps = formatRanges.some(range =>
            (match.index < range.end && match.index + match[0].length > range.start)
        );
        if (!overlaps) {
            formatRanges.push({
                start: match.index,
                end: match.index + match[0].length,
                content: match[1],
                type: 'italic'
            });
        }
    }

    // Sort ranges by start position
    formatRanges.sort((a, b) => a.start - b.start);

    // Build segments from ranges
    let currentIndex = 0;
    formatRanges.forEach(range => {
        // Add text before the formatted range
        if (currentIndex < range.start) {
            const beforeText = text.slice(currentIndex, range.start);
            if (beforeText) {
                segments.push({ text: beforeText, type: 'normal' });
            }
        }

        // Add the formatted text
        segments.push({ text: range.content, type: range.type });
        currentIndex = range.end;
    });

    // Add remaining text
    if (currentIndex < text.length) {
        const remainingText = text.slice(currentIndex);
        if (remainingText) {
            segments.push({ text: remainingText, type: 'normal' });
        }
    }

    // If no formatting found, return the original text
    if (segments.length === 0) {
        segments.push({ text: text, type: 'normal' });
    }

    return segments;
}

// Calculate the total height needed for rendered markdown content
export function calculateMarkdownHeight(ctx, text, maxWidth, margins = 16, baseFontSize = 14) {
    // Handle both old padding format and new margins object
    const marginConfig = typeof margins === 'object' ? margins : {
        top: margins / 2,
        bottom: margins / 2,
        left: margins / 2,
        right: margins / 2
    };

    const parsed = parseMarkdown(text, baseFontSize);
    let totalHeight = marginConfig.top; // Top margin
    
    parsed.forEach(item => {
        if (item.type === 'spacing') {
            totalHeight += item.fontSize;
            return;
        }
        
        // Set font for measurement
        const font = `${item.fontWeight} ${item.fontStyle} ${item.fontSize}px Arial`;
        ctx.font = font;
        
        let lineHeight = item.fontSize + 4; // Base line height with spacing
        
        // Adjust line height for different types
        if (item.type === 'header') {
            lineHeight = item.fontSize + 8; // More spacing for headers
        } else if (item.type === 'list') {
            lineHeight = item.fontSize + 6; // Slightly more spacing for lists
        }
        
        if (Array.isArray(item.content)) {
            // Handle inline formatted content
            const fullText = item.content.map(segment => segment.text).join('');
            const wrappedLines = wrapTextForMarkdown(ctx, fullText, maxWidth - marginConfig.left - marginConfig.right, item);
            totalHeight += wrappedLines.length * lineHeight;
        } else {
            // Handle simple content
            const wrappedLines = wrapTextForMarkdown(ctx, item.content, maxWidth - marginConfig.left - marginConfig.right, item);
            totalHeight += wrappedLines.length * lineHeight;
        }
    });

    return Math.max(80, totalHeight + marginConfig.bottom); // Increased minimum height from 60 to 80 to align with new default height
}

// Enhanced text wrapping that considers formatting
function wrapTextForMarkdown(ctx, text, maxWidth, item) {
    if (!text) return [''];

    // Set the correct font for measurement
    const font = `${item.fontWeight} ${item.fontStyle} ${item.fontSize}px Arial`;
    ctx.font = font;

    const words = text.split(' ');
    const lines = [];
    let currentLine = '';

    // Account for list bullets
    const effectiveMaxWidth = item.type === 'list' ? maxWidth - 20 : maxWidth;

    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);

        if (metrics.width > effectiveMaxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });

    if (currentLine) {
        lines.push(currentLine);
    }

    return lines.length > 0 ? lines : [''];
}



---
File: /infinite_canvas_v5/src/markdownRenderer.js
---

// Canvas markdown renderer - renders parsed markdown to canvas
import { parseMarkdown } from './markdownParser.js';

export function renderMarkdownToCanvas(ctx, text, x, y, maxWidth, nodeHeight, margins = 16, scrollY = 0, baseFontSize = 14) {
    // Handle both old padding format and new margins object
    const marginConfig = typeof margins === 'object' ? margins : {
        top: margins / 2,
        bottom: margins / 2,
        left: margins / 2,
        right: margins / 2
    };

    const parsed = parseMarkdown(text, baseFontSize);
    let currentY = y + marginConfig.top - scrollY; // Apply scroll offset
    const maxY = y + nodeHeight - marginConfig.bottom;

    // Save original context state
    ctx.save();

    // Create clipping region to prevent content from rendering outside the node
    ctx.beginPath();
    ctx.rect(x, y, maxWidth, nodeHeight);
    ctx.clip();
    
    parsed.forEach(item => {
        if (item.type === 'spacing') {
            currentY += item.fontSize;
            return;
        }
        
        // Calculate line height
        let lineHeight = item.fontSize + 4;
        if (item.type === 'header') {
            lineHeight = item.fontSize + 8;
        } else if (item.type === 'list') {
            lineHeight = item.fontSize + 6;
        }
        
        // Skip rendering if this item is above the visible area
        if (currentY + lineHeight < y) {
            currentY += lineHeight;
            return;
        }

        // Stop rendering if we're below the visible area
        if (currentY > maxY) {
            return;
        }
        
        if (Array.isArray(item.content)) {
            // Handle inline formatted content
            currentY = renderInlineFormattedText(ctx, item, x, currentY, maxWidth, marginConfig, lineHeight, maxY, y);
        } else {
            // Handle simple content
            currentY = renderSimpleText(ctx, item, x, currentY, maxWidth, marginConfig, lineHeight, maxY, y);
        }
    });
    
    // Restore context state
    ctx.restore();
    
    return currentY - y; // Return total height used
}

function renderSimpleText(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y) {
    // Set font properties
    const font = `${item.fontWeight} ${item.fontStyle} ${item.fontSize}px Arial`;
    ctx.font = font;
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Handle different text types
    if (item.type === 'list') {
        return renderListItem(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y);
    } else {
        return renderRegularText(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y);
    }
}

function renderRegularText(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y) {
    const effectiveMaxWidth = maxWidth - margins.left - margins.right;
    const textX = x + margins.left;

    // Handle both string content and array content (inline formatting)
    if (Array.isArray(item.content)) {
        // For inline formatted content, we need to render each segment with its own formatting
        return renderInlineFormattedText(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y);
    } else {
        // For simple string content, wrap and render normally
        const lines = wrapTextForRendering(ctx, item.content, effectiveMaxWidth);

        lines.forEach(line => {
            if (currentY > maxY) return; // Stop if below visible area
            if (currentY + lineHeight >= y) { // Only render if in visible area
                ctx.fillText(line, textX, currentY);
            }
            currentY += lineHeight;
        });

        return currentY;
    }
}

function renderListItem(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y) {
    const bulletX = x + margins.left;
    const textX = bulletX + 20;
    const effectiveMaxWidth = maxWidth - margins.left - margins.right - 20;

    // Draw bullet point
    ctx.fillText(item.bullet, bulletX, currentY);

    // Handle both string content and array content (inline formatting)
    if (Array.isArray(item.content)) {
        // For inline formatted content, render with formatting
        return renderInlineFormattedText(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y);
    } else {
        // For simple string content, wrap and render normally
        const lines = wrapTextForRendering(ctx, item.content, effectiveMaxWidth);

        lines.forEach((line) => {
            if (currentY > maxY) return; // Stop if below visible area
            if (currentY + lineHeight >= y) { // Only render if in visible area
                ctx.fillText(line, textX, currentY);
            }
            currentY += lineHeight;
        });

        return currentY;
    }
}

function renderInlineFormattedText(ctx, item, x, currentY, maxWidth, margins, lineHeight, maxY, y) {
    const effectiveMaxWidth = maxWidth - margins.left - margins.right;
    let textX = x + margins.left;

    // Handle list items with inline formatting
    if (item.type === 'list') {
        const bulletX = x + margins.left;
        textX = bulletX + 20;

        // Draw bullet point
        ctx.font = `${item.fontWeight} ${item.fontStyle} ${item.fontSize}px Arial`;
        ctx.fillStyle = '#ffffff';
        ctx.fillText(item.bullet, bulletX, currentY);
    }

    // Simplified approach: render each segment on the same line if possible
    const segments = item.content;
    let currentLineX = textX;
    let maxLineWidth = effectiveMaxWidth - (item.type === 'list' ? 20 : 0);

    // First, try to render all segments on one line
    let totalWidth = 0;
    segments.forEach(segment => {
        setFontForSegment(ctx, segment, item.fontSize);
        totalWidth += ctx.measureText(segment.text).width;
    });

    if (totalWidth <= maxLineWidth) {
        // All segments fit on one line
        segments.forEach(segment => {
            setFontForSegment(ctx, segment, item.fontSize);
            ctx.fillText(segment.text, currentLineX, currentY);
            currentLineX += ctx.measureText(segment.text).width;
        });
        return currentY + lineHeight;
    } else {
        // Need to wrap - fall back to simple text rendering
        const fullText = segments.map(segment => segment.text).join('');
        const lines = wrapTextForRendering(ctx, fullText, maxLineWidth);

        // Set font for the whole text block
        ctx.font = `${item.fontWeight} ${item.fontStyle} ${item.fontSize}px Arial`;
        ctx.fillStyle = '#ffffff';

        lines.forEach(line => {
            if (currentY > maxY) return; // Stop if below visible area
            if (currentY + lineHeight >= y) { // Only render if in visible area
                ctx.fillText(line, textX, currentY);
            }
            currentY += lineHeight;
        });

        return currentY;
    }
}



function setFontForSegment(ctx, segment, baseFontSize) {
    ctx.font = getFontForSegment(segment, baseFontSize);
    
    // Set color based on segment type
    if (segment.type === 'code') {
        ctx.fillStyle = '#fbb6ce'; // Light pink code color for dark background
    } else {
        ctx.fillStyle = '#ffffff';
    }
}

function getFontForSegment(segment, baseFontSize) {
    let fontWeight = 'normal';
    let fontStyle = 'normal';
    let fontFamily = 'Arial';
    
    if (segment.type === 'bold') {
        fontWeight = 'bold';
    } else if (segment.type === 'italic') {
        fontStyle = 'italic';
    } else if (segment.type === 'code') {
        fontFamily = 'Monaco, Consolas, monospace';
    }
    
    return `${fontWeight} ${fontStyle} ${baseFontSize}px ${fontFamily}`;
}

function wrapTextForRendering(ctx, text, maxWidth) {
    if (!text) return [''];

    // Handle both string and array content
    let textToWrap = text;
    if (Array.isArray(text)) {
        // If it's an array of segments (inline formatting), join them for wrapping
        textToWrap = text.map(segment => segment.text).join('');
    }

    const words = textToWrap.split(' ');
    const lines = [];
    let currentLine = '';

    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);

        if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });

    if (currentLine) {
        lines.push(currentLine);
    }

    return lines.length > 0 ? lines : [''];
}



---
File: /infinite_canvas_v5/src/UIManager.js
---

// UIManager.js - Handles all UI elements and interactions
import { parseMarkdown } from './markdownParser.js';

export class UIManager {
    constructor(canvasState) {
        this.canvasState = canvasState;
        this.aiManager = null; // Set by InfiniteCanvas after construction
        
        // Progress notification state
        this.progressNotificationTimeout = null;
        this.isProgressNotificationVisible = false;
        
        // Aspect ratio state
        this.selectedAspectRatio = '1:1'; // Default
        this.aspectRatioSelectorVisible = false;
        this.aspectRatioTimeout = null;
        
        this.setupUI();
    }
    
    // Set AIManager after it's created
    setAIManager(aiManager) {
        this.aiManager = aiManager;
    }
    
    setupUI() {
        this.setupAPIKeyUI();
        this.setupModelSelector();
        this.setupContentModal();
        this.setupAspectRatioSelector();
        const downloadImageBtn = document.getElementById('downloadImageBtn');
        if (downloadImageBtn) {
            downloadImageBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.canvasState.selectedNodes.length === 1) {
                    const node = this.canvasState.selectedNodes[0];
                    if (node.generatedImageUrl) {
                        this.downloadNodeImage(node);
                    }
                }
            });
        }
    }
    
    // API Configuration Modal
    setupAPIKeyUI() {
        if (!document.getElementById('apiKeyModal')) {
            const modal = document.createElement('div');
            modal.id = 'apiKeyModal';
            modal.className = 'api-key-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Configuration & Actions</h3>
                        <button id="closeConfigModalBtn" class="close-modal-btn">×</button>
                    </div>

                    <!-- Canvas Actions -->
                    <div class="modal-section">
                        <h4>Canvas Actions</h4>
                        <div class="modal-action-buttons">
                            <button id="modalExportBtn" class="modal-action-btn">Export JSON</button>
                            <button id="modalImportBtn" class="modal-action-btn">Import JSON</button>
                        </div>
                    </div>

                    <!-- TEXT MODELS CONFIGURATION -->
                    <div class="modal-section">
                        <h4>🧠 Text Models Configuration</h4>
                        <p>Configure AI models for text generation, idea generation, and conversations:</p>

                        <div class="demo-mode-section">
                            <label class="demo-toggle">
                                <input type="checkbox" id="demoModeToggle" />
                                <span class="demo-toggle-text">🎯 Use Demo Mode (Free - No API Key Required)</span>
                            </label>
                            <p class="demo-description">Demo mode uses free Groq API with Llama 3.3 70B & other powerful models. Perfect for trying the app!</p>
                        </div>

                        <div id="apiConfigSection">
                            <div class="config-subsection">
                                <h5>🔗 Text Models API Settings</h5>
                                <label for="baseUrlInput">Base URL:</label>
                                <input type="text" id="baseUrlInput" placeholder="https://api.openai.com/v1" />

                                <label for="apiKeyInput">Text Models API Key:</label>
                                <input type="password" id="apiKeyInput" placeholder="sk-... (OpenAI), or-... (OpenRouter), or gsk_... (Groq)" />
                                <small style="display: block; margin-bottom: 15px; color: #666;">
                                    Use your API key from OpenAI, OpenRouter, Groq, or other compatible providers.
                                </small>

                                <label for="aiModelsInput">Available Text Models (comma-separated):</label>
                                <input type="text" id="aiModelsInput" placeholder="gpt-4o, claude-3-5-sonnet-20241022, llama-3.3-70b-versatile" />
                                <button type="button" id="updateModelsBtn" style="margin-top: 5px; padding: 5px 10px; background: #0d7377; color: white; border: none; border-radius: 4px; cursor: pointer;">Update Model List</button>
                                <small style="display: block; margin-bottom: 15px; color: #666;">
                                    Enter model names separated by commas, then click "Update Model List" to select which ones to activate.
                                </small>

                                <div id="modelSelectionSection" style="margin-top: 15px;">
                                    <label style="font-weight: bold; margin-bottom: 10px; display: block;">Select Active Text Models:</label>
                                    <div id="modelCheckboxes" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; border-radius: 4px; padding: 10px; background: #2a2a2a;">
                                        <!-- Model checkboxes will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- IMAGE/VIDEO MODELS CONFIGURATION -->
                    <div class="modal-section" data-section="image-models">
                        <h4>🎨 Image & Video Models Configuration</h4>
                        <p>Configure AI models for image generation, editing, and video creation:</p>

                        <div class="config-subsection">
                            <h5>🔗 Image/Video Models API Settings</h5>
                            
                            <label for="replicateApiKeyInput">Replicate API Key:</label>
                            <input type="password" id="replicateApiKeyInput" placeholder="r8_..." />
                            <small style="display: block; margin-bottom: 15px; color: #666;">
                                Get your free API key from <a href="https://replicate.com/account/api-tokens" target="_blank" style="color: #0d7377;">replicate.com/account/api-tokens</a>. Required for image and video generation.
                            </small>

                            <div data-section="image-model-inputs">
                                <label for="imageModelsInput">Available Image/Video Models (comma-separated):</label>
                                <input type="text" id="imageModelsInput" placeholder="recraft-ai/recraft-v3, google/imagen-4, bytedance/seedream-3" />
                                <button type="button" id="updateImageModelsBtn" style="margin-top: 5px; padding: 5px 10px; background: #0d7377; color: white; border: none; border-radius: 4px; cursor: pointer;">Update Image Model List</button>
                                <small style="display: block; margin-bottom: 15px; color: #666;">
                                    Enter image/video model names from Replicate, separated by commas.
                                </small>

                                <div id="imageModelSelectionSection" style="margin-top: 15px;">
                                    <label style="font-weight: bold; margin-bottom: 10px; display: block;">Select Active Image/Video Models:</label>
                                    <div id="imageModelCheckboxes" style="max-height: 200px; overflow-y: auto; border: 1px solid #444; border-radius: 4px; padding: 10px; background: #2a2a2a;">
                                        <!-- Image model checkboxes will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="modal-buttons">
                        <button id="saveApiKeyBtn">Save Configuration</button>
                        <button id="cancelApiKeyBtn">Close</button>
                    </div>
                    <small>
                        <strong>🧠 Text Model Providers:</strong><br>
                        • OpenAI: https://api.openai.com/v1<br>
                        • OpenRouter: https://openrouter.ai/api/v1<br>
                        • Groq: https://api.groq.com/openai/v1<br>
                        • Local models: http://localhost:1234/v1<br>
                        <br>
                        <strong>🎨 Image/Video Providers:</strong><br>
                        • Replicate: https://replicate.com (handles all image/video models)<br>
                        <br>
                        <em>Your settings are stored locally and never shared.</em>
                    </small>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add event listeners
            document.getElementById('saveApiKeyBtn').addEventListener('click', () => this.saveApiConfig());
            document.getElementById('cancelApiKeyBtn').addEventListener('click', () => this.hideApiKeyModal());
            document.getElementById('closeConfigModalBtn').addEventListener('click', () => this.hideApiKeyModal());
            document.getElementById('demoModeToggle').addEventListener('change', (e) => this.toggleDemoMode(e.target.checked));
            document.getElementById('updateModelsBtn').addEventListener('click', () => this.updateModelList());
            document.getElementById('updateImageModelsBtn').addEventListener('click', () => this.updateImageModelList());
            
            // Add listener for Replicate API key to dynamically show/hide image models section
            document.getElementById('replicateApiKeyInput').addEventListener('input', () => {
                this.updateModalImageModelsVisibility();
            });
            
            // Modal action buttons
            document.getElementById('modalExportBtn').addEventListener('click', () => {
                this.exportJSON();
                this.hideApiKeyModal();
            });
            document.getElementById('modalImportBtn').addEventListener('click', () => {
                this.importJSON();
                this.hideApiKeyModal();
            });
        }
        
        this.updateApiConfigButton();
    }
    
    showApiKeyModal() {
        if (!this.aiManager) return;
        
        const modal = document.getElementById('apiKeyModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const replicateApiKeyInput = document.getElementById('replicateApiKeyInput');
        const baseUrlInput = document.getElementById('baseUrlInput');
        const aiModelsInput = document.getElementById('aiModelsInput');
        const demoModeToggle = document.getElementById('demoModeToggle');
        const imageModelsInput = document.getElementById('imageModelsInput');

        modal.style.display = 'flex';

        // Set current values
        apiKeyInput.value = this.aiManager.apiKey || '';
        replicateApiKeyInput.value = this.aiManager.replicateApiKey || '';
        baseUrlInput.value = this.aiManager.baseURL || 'https://api.openai.com/v1';
        aiModelsInput.value = this.aiManager.aiModels || 'gpt-3.5-turbo';
        imageModelsInput.value = this.aiManager.imageModels || '';
        demoModeToggle.checked = this.aiManager.demoMode;

        this.toggleApiConfigVisibility(!this.aiManager.demoMode);
        this.updateModalImageModelsVisibility();
        this.updateModelList();
        this.updateImageModelList();

        if (this.aiManager.demoMode) {
            demoModeToggle.focus();
        } else {
            baseUrlInput.focus();
        }
    }
    
    hideApiKeyModal() {
        document.getElementById('apiKeyModal').style.display = 'none';
    }

    toggleDemoMode(enabled) {
        this.toggleApiConfigVisibility(!enabled);
        if (enabled) {
            console.log('🎯 Demo mode enabled - using free Hugging Face models');
        } else {
            console.log('🔑 Demo mode disabled - using custom API configuration');
        }
    }

    toggleApiConfigVisibility(visible) {
        const apiConfigSection = document.getElementById('apiConfigSection');
        if (apiConfigSection) {
            apiConfigSection.style.display = visible ? 'block' : 'none';
        }
    }

    updateModalImageModelsVisibility() {
        const replicateApiKeyInput = document.getElementById('replicateApiKeyInput');
        const imageModelInputs = document.querySelector('[data-section="image-model-inputs"]');
        
        if (!replicateApiKeyInput || !imageModelInputs) return;
        
        const hasReplicateKey = replicateApiKeyInput.value.trim() !== '';
        imageModelInputs.style.display = hasReplicateKey ? 'block' : 'none';
        
        // Also update the model selector UI when API key changes
        if (this.aiManager) {
            this.aiManager.replicateApiKey = replicateApiKeyInput.value.trim();
            this.updateModelSelectorUI();
        }
    }

    updateModelList() {
        if (!this.aiManager) return;
        
        const aiModelsInput = document.getElementById('aiModelsInput');
        const modelCheckboxes = document.getElementById('modelCheckboxes');

        if (!aiModelsInput || !modelCheckboxes) return;

        const modelsText = aiModelsInput.value.trim();
        if (!modelsText) {
            modelCheckboxes.innerHTML = '<p style="color: #666; font-style: italic;">Enter models above to see selection options</p>';
            return;
        }

        const models = modelsText.split(',').map(m => m.trim()).filter(m => m.length > 0);

        if (models.length === 0) {
            modelCheckboxes.innerHTML = '<p style="color: #666; font-style: italic;">No valid models found</p>';
            return;
        }

        modelCheckboxes.innerHTML = '';
        models.forEach((model, index) => {
            const isActive = this.aiManager.activeModels[model] !== false;

            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = 'margin-bottom: 8px; display: flex; align-items: center; gap: 8px;';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `model_${index}`;
            checkbox.checked = isActive;
            checkbox.style.cssText = 'margin: 0;';

            const label = document.createElement('label');
            label.htmlFor = `model_${index}`;
            label.textContent = model;
            label.style.cssText = 'color: #e0e0e0; cursor: pointer; flex: 1; font-size: 14px;';

            checkbox.addEventListener('change', () => {
                this.aiManager.activeModels[model] = checkbox.checked;
            });

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);
            modelCheckboxes.appendChild(checkboxContainer);
        });

        // Add select all/none buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'margin-top: 10px; display: flex; gap: 8px;';

        const selectAllBtn = document.createElement('button');
        selectAllBtn.textContent = 'Select All';
        selectAllBtn.style.cssText = 'padding: 4px 8px; background: #0d7377; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;';
        selectAllBtn.addEventListener('click', () => this.selectAllModels(true));

        const selectNoneBtn = document.createElement('button');
        selectNoneBtn.textContent = 'Select None';
        selectNoneBtn.style.cssText = 'padding: 4px 8px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;';
        selectNoneBtn.addEventListener('click', () => this.selectAllModels(false));

        buttonContainer.appendChild(selectAllBtn);
        buttonContainer.appendChild(selectNoneBtn);
        modelCheckboxes.appendChild(buttonContainer);
        
        this.updateModelSelectorUI();
    }

    updateImageModelList() {
        if (!this.aiManager) return;
        
        const imageModelsInput = document.getElementById('imageModelsInput');
        const imageModelCheckboxes = document.getElementById('imageModelCheckboxes');

        if (!imageModelsInput || !imageModelCheckboxes) return;

        const modelsText = imageModelsInput.value.trim();
        if (!modelsText) {
            imageModelCheckboxes.innerHTML = '<p style="color: #666; font-style: italic;">Enter image models above to see selection options</p>';
            return;
        }

        const models = modelsText.split(',').map(m => m.trim()).filter(m => m.length > 0);

        if (models.length === 0) {
            imageModelCheckboxes.innerHTML = '<p style="color: #666; font-style: italic;">No valid image models found</p>';
            return;
        }

        imageModelCheckboxes.innerHTML = '';
        models.forEach((model, index) => {
            const isActive = this.aiManager.activeImageModels[model] !== false;

            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = 'margin-bottom: 8px; display: flex; align-items: center; gap: 8px;';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `imageModel_${index}`;
            checkbox.checked = isActive;
            checkbox.style.cssText = 'margin: 0;';

            const label = document.createElement('label');
            label.htmlFor = `imageModel_${index}`;
            label.textContent = model;
            label.style.cssText = 'color: #e0e0e0; cursor: pointer; flex: 1; font-size: 14px;';

            checkbox.addEventListener('change', () => {
                this.aiManager.activeImageModels[model] = checkbox.checked;
            });

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);
            imageModelCheckboxes.appendChild(checkboxContainer);
        });

        // Add select all/none buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'margin-top: 10px; display: flex; gap: 8px;';

        const selectAllBtn = document.createElement('button');
        selectAllBtn.textContent = 'Select All';
        selectAllBtn.style.cssText = 'padding: 4px 8px; background: #0d7377; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;';
        selectAllBtn.addEventListener('click', () => this.selectAllImageModels(true));

        const selectNoneBtn = document.createElement('button');
        selectNoneBtn.textContent = 'Select None';
        selectNoneBtn.style.cssText = 'padding: 4px 8px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;';
        selectNoneBtn.addEventListener('click', () => this.selectAllImageModels(false));

        buttonContainer.appendChild(selectAllBtn);
        buttonContainer.appendChild(selectNoneBtn);
        imageModelCheckboxes.appendChild(buttonContainer);
        
        this.updateImageModelSelectorUI();
    }

    selectAllModels(select) {
        if (!this.aiManager) return;
        
        // Update modal checkboxes if they exist
        const modelCheckboxes = document.getElementById('modelCheckboxes');
        if (modelCheckboxes) {
            const modalCheckboxes = modelCheckboxes.querySelectorAll('input[type="checkbox"]');
            modalCheckboxes.forEach(checkbox => {
                checkbox.checked = select;
                checkbox.dispatchEvent(new Event('change'));
            });
        }

        // Update persistent panel checkboxes
        const modelContainer = document.getElementById('modelCheckboxesContainer');
        if (modelContainer) {
            const panelCheckboxes = modelContainer.querySelectorAll('input[type="checkbox"]');
            panelCheckboxes.forEach(checkbox => {
                checkbox.checked = select;
                checkbox.dispatchEvent(new Event('change'));
            });
        }
    }
    
    selectAllImageModels(select) {
        if (!this.aiManager) return;
        
        // Update modal checkboxes if they exist
        const imageModelCheckboxes = document.getElementById('imageModelCheckboxes');
        if (imageModelCheckboxes) {
            const modalCheckboxes = imageModelCheckboxes.querySelectorAll('input[type="checkbox"]');
            modalCheckboxes.forEach(checkbox => {
                checkbox.checked = select;
                checkbox.dispatchEvent(new Event('change'));
            });
        }

        // Update persistent panel checkboxes for image models
        const modelContainer = document.getElementById('modelCheckboxesContainer');
        if (modelContainer) {
            const imageCheckboxes = modelContainer.querySelectorAll('input[id^="image_"]');
            imageCheckboxes.forEach(checkbox => {
                checkbox.checked = select;
                checkbox.dispatchEvent(new Event('change'));
            });
        }
    }
    
    saveApiConfig() {
        if (!this.aiManager) return;
        
        const demoModeToggle = document.getElementById('demoModeToggle');
        const demoMode = demoModeToggle.checked;

        if (demoMode) {
            // Demo mode
            this.aiManager.saveApiConfig(
                null, // apiKey
                null, // replicateApiKey
                null, // baseURL
                this.aiManager.demoModels, // aiModels
                {}, // activeModels - will be set in saveApiConfig
                true, // demoMode
                this.aiManager.imageModels, // imageModels
                this.aiManager.activeImageModels // activeImageModels
            );

            // Set all demo models as active
            const demoModelsList = this.aiManager.demoModels.split(',').map(m => m.trim());
            demoModelsList.forEach(model => {
                this.aiManager.activeModels[model] = true;
            });

            this.hideApiKeyModal();
            this.updateApiConfigButton();
            this.updateModelSelectorUI();
            this.updateImageModelSelectorUI();

            const modelCount = this.aiManager.demoModels.split(',').length;
            this.showNotification(`🎯 Demo mode enabled with ${modelCount} free model(s)!`, 'success');
        } else {
            // Regular API mode
            const apiKeyInput = document.getElementById('apiKeyInput');
            const replicateApiKeyInput = document.getElementById('replicateApiKeyInput');
            const baseUrlInput = document.getElementById('baseUrlInput');
            const aiModelsInput = document.getElementById('aiModelsInput');
            const imageModelsInput = document.getElementById('imageModelsInput');
            
            const apiKey = apiKeyInput.value.trim();
            const replicateApiKey = replicateApiKeyInput.value.trim();
            const baseURL = baseUrlInput.value.trim();
            const aiModels = aiModelsInput.value.trim();
            const imageModels = imageModelsInput.value.trim();

            if (!apiKey) {
                this.showNotification('Please enter an API key', 'error');
                return;
            }

            if (!baseURL) {
                this.showNotification('Please enter a base URL', 'error');
                return;
            }

            if (!aiModels) {
                this.showNotification('Please enter at least one AI model', 'error');
                return;
            }

            try {
                new URL(baseURL);
            } catch (e) {
                this.showNotification('Please enter a valid URL', 'error');
                return;
            }

            this.aiManager.saveApiConfig(
                apiKey,
                replicateApiKey,
                baseURL,
                aiModels,
                this.aiManager.activeModels,
                false, // demoMode
                imageModels,
                this.aiManager.activeImageModels
            );

            this.hideApiKeyModal();
            this.updateApiConfigButton();
            this.updateModelSelectorUI();
            this.updateImageModelSelectorUI();

            const provider = this.aiManager.getProviderName();
            const modelCount = aiModels.split(',').length;
            this.showNotification(`${provider} configuration saved with ${modelCount} model(s)!`, 'success');
        }
    }
    
    updateApiConfigButton() {
        if (!this.aiManager) return;
        
        const btn = document.getElementById('configureBtn');
        if (!btn) return;
        
        if (this.aiManager.demoMode) {
            btn.textContent = '⚙️ Configure (Demo Active)';
            btn.title = 'Demo mode is active with free Hugging Face models. Click to configure.';
            btn.style.background = '#17a2b8';
        } else if (this.aiManager.apiKey) {
            const provider = this.aiManager.getProviderName();
            btn.textContent = `⚙️ Configure (${provider})`;
            btn.title = `API configured for ${provider}. Click to configure.`;
            btn.style.background = '#28a745';
        } else {
            btn.textContent = '⚙️ Configure';
            btn.title = 'Configure AI API settings and canvas actions';
            btn.style.background = '#dc3545';
        }
    }

    // Model Selector Panel
    setupModelSelector() {
        const modelPanel = document.querySelector('.model-selector-panel');
        const toggleBtn = document.getElementById('toggleModelsBtn');
        const panelHeader = document.getElementById('modelPanelHeader');
        const modelContainer = document.getElementById('modelCheckboxesContainer');
        const dragHandle = document.getElementById('dragHandle');

        if (!modelPanel || !toggleBtn || !modelContainer || !dragHandle) {
            console.error('Model selector elements not found');
            return;
        }

        this.loadPanelPosition(modelPanel);

        let isCollapsed = localStorage.getItem('model_panel_collapsed') === 'true';
        
        const updatePanelState = () => {
            if (isCollapsed) {
                modelContainer.classList.add('collapsed');
                toggleBtn.textContent = '▼';
                toggleBtn.title = 'Show Models';
            } else {
                modelContainer.classList.remove('collapsed');
                toggleBtn.textContent = '▲';
                toggleBtn.title = 'Hide Models';
            }
        };

        updatePanelState();

        const togglePanel = () => {
            isCollapsed = !isCollapsed;
            localStorage.setItem('model_panel_collapsed', isCollapsed.toString());
            updatePanelState();
        };

        toggleBtn.addEventListener('click', togglePanel);
        panelHeader.addEventListener('click', togglePanel);

        this.setupPanelDrag(modelPanel, dragHandle);

        window.addEventListener('resize', () => {
            this.constrainPanelToBounds(modelPanel);
        });

        this.updateModelSelectorUI();
    }

    updateModelSelectorUI() {
        if (!this.aiManager) return;

        const container = document.getElementById('modelCheckboxesContainer');
        const activeCountSpan = document.getElementById('activeModelCount');
        if (!container || !activeCountSpan) return;

        // --- Text Models ---
        const allTextModels = (this.aiManager.aiModels || '').split(',').map(m => m.trim()).filter(m => m.length > 0);
        const activeTextModels = allTextModels.filter(model => this.aiManager.activeModels[model] !== false);

        // --- Image Models (only if Replicate API key is available) ---
        const hasReplicateKey = this.aiManager.replicateApiKey && this.aiManager.replicateApiKey.trim() !== '';
        const allImageModels = hasReplicateKey ? (this.aiManager.imageModels || '').split(',').map(m => m.trim()).filter(m => m.length > 0) : [];
        const activeImageModels = hasReplicateKey ? allImageModels.filter(model => this.aiManager.activeImageModels[model] !== false) : [];
        
        // Update active count (only count image models if Replicate key is available)
        const totalActiveModels = activeTextModels.length + (hasReplicateKey ? activeImageModels.length : 0);
        activeCountSpan.textContent = `${totalActiveModels} active`;
        container.innerHTML = '';
        
        // Create text models section header
        const textHeader = document.createElement('div');
        textHeader.className = 'model-section-header';
        textHeader.textContent = `📝 Text Models (${activeTextModels.length})`;
        container.appendChild(textHeader);
        
        // Render Text Models
        if (allTextModels.length > 0) {
            allTextModels.forEach((model, index) => {
                const isActive = this.aiManager.activeModels[model] !== false;
                const checkboxItem = this.createModelCheckboxItem(model, `text_${index}`, isActive, 'ai');
                container.appendChild(checkboxItem);
            });
        } else {
            const noTextModels = document.createElement('div');
            noTextModels.className = 'no-active-models';
            noTextModels.textContent = 'No text models.';
            container.appendChild(noTextModels);
        }
        
        // Create image models section header
        const imageHeader = document.createElement('div');
        imageHeader.className = 'model-section-header';
        imageHeader.textContent = '🖼️ Image Models' + (hasReplicateKey ? ` (${activeImageModels.length})` : '');
        container.appendChild(imageHeader);
        
        // Render Image Models (only if Replicate API key is available)
        if (hasReplicateKey) {
            if (allImageModels.length > 0) {
                allImageModels.forEach((model, index) => {
                    const isActive = this.aiManager.activeImageModels[model] !== false;
                    const checkboxItem = this.createModelCheckboxItem(model, `image_${index}`, isActive, 'image');
                    container.appendChild(checkboxItem);
                });
            } else {
                const noImageModels = document.createElement('div');
                noImageModels.className = 'no-active-models';
                noImageModels.textContent = 'No image models.';
                container.appendChild(noImageModels);
            }
        } else {
            // Show message when no Replicate API key is configured
            const noReplicateKey = document.createElement('div');
            noReplicateKey.className = 'no-active-models';
            noReplicateKey.style.cssText = 'color: #888; font-style: italic;';
            noReplicateKey.textContent = 'Configure Replicate API key to enable image models';
            container.appendChild(noReplicateKey);
        }
    }

    createModelCheckboxItem(model, index, isActive, type = 'ai') {
        const checkboxId = `panel_${type}_${index}`;
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'model-checkbox-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.checked = isActive;
        
        const label = document.createElement('label');
        label.htmlFor = checkboxId;
        label.textContent = model;
        
        checkbox.addEventListener('change', () => {
            if (type === 'ai') {
                this.aiManager.activeModels[model] = checkbox.checked;
            } else {
                this.aiManager.activeImageModels[model] = checkbox.checked;
            }
            this.updateModelSelectorUI();
        });

        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);
        
        return checkboxContainer;
    }

    updateImageModelSelectorUI() {
        // This function updates the image model selector UI
        // Since updateModelSelectorUI() already handles both text and image models,
        // we can simply call it to refresh the entire UI
        this.updateModelSelectorUI();
    }

    setupPanelDrag(panel, dragHandle) {
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        const onMouseDown = (e) => {
            if (!dragHandle.contains(e.target)) return;

            isDragging = true;
            const rect = panel.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            e.preventDefault();

            panel.classList.add('dragging');
            document.body.style.userSelect = 'none';

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        };

        const onMouseMove = (e) => {
            if (!isDragging) return;

            e.preventDefault();

            let newX = e.clientX - dragOffset.x;
            let newY = e.clientY - dragOffset.y;

            const constraints = this.getPanelConstraints(panel);
            newX = Math.max(constraints.minX, Math.min(constraints.maxX, newX));
            newY = Math.max(constraints.minY, Math.min(constraints.maxY, newY));

            panel.style.left = newX + 'px';
            panel.style.top = newY + 'px';
            panel.style.right = 'auto';
            panel.style.bottom = 'auto';
        };

        const onMouseUp = () => {
            if (!isDragging) return;

            isDragging = false;
            panel.classList.remove('dragging');
            document.body.style.userSelect = '';

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);

            this.savePanelPosition(panel);
        };

        dragHandle.addEventListener('mousedown', onMouseDown);
    }

    getPanelConstraints(panel) {
        const panelRect = panel.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const margin = 10;

        return {
            minX: margin,
            minY: margin,
            maxX: viewportWidth - panelRect.width - margin,
            maxY: viewportHeight - panelRect.height - margin
        };
    }

    loadPanelPosition(panel) {
        const savedPosition = localStorage.getItem('model_panel_position');
        if (savedPosition) {
            try {
                const position = JSON.parse(savedPosition);
                const constraints = this.getPanelConstraints(panel);
                const validX = Math.max(constraints.minX, Math.min(constraints.maxX, position.x));
                const validY = Math.max(constraints.minY, Math.min(constraints.maxY, position.y));

                panel.style.left = validX + 'px';
                panel.style.top = validY + 'px';
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
            } catch (e) {
                console.warn('Failed to load panel position:', e);
            }
        }
    }

    savePanelPosition(panel) {
        const rect = panel.getBoundingClientRect();
        const position = {
            x: rect.left,
            y: rect.top
        };
        localStorage.setItem('model_panel_position', JSON.stringify(position));
    }

    constrainPanelToBounds(panel) {
        const rect = panel.getBoundingClientRect();
        const constraints = this.getPanelConstraints(panel);

        let newX = rect.left;
        let newY = rect.top;
        let needsUpdate = false;

        if (newX < constraints.minX) {
            newX = constraints.minX;
            needsUpdate = true;
        } else if (newX > constraints.maxX) {
            newX = constraints.maxX;
            needsUpdate = true;
        }

        if (newY < constraints.minY) {
            newY = constraints.minY;
            needsUpdate = true;
        } else if (newY > constraints.maxY) {
            newY = constraints.maxY;
            needsUpdate = true;
        }

        if (needsUpdate) {
            panel.style.left = newX + 'px';
            panel.style.top = newY + 'px';
            this.savePanelPosition(panel);
        }
    }

    // Content Modal
    setupContentModal() {
        // Modal close handlers
        document.getElementById('closeModalBtn').addEventListener('click', () => this.hideContentModal());
        document.getElementById('contentModal').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-backdrop')) {
                this.hideContentModal();
            }
        });
        document.getElementById('editModalBtn').addEventListener('click', () => this.toggleModalEditMode());
    }

    showContentModal() {
        if (this.canvasState.selectedNodes.length !== 1) {
            this.showNotification('Please select exactly one node to expand its content', 'warning');
            return;
        }

        const selectedNode = this.canvasState.selectedNodes[0];
        const modal = document.getElementById('contentModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalContent');

        modalTitle.textContent = 'Node Content';

        const htmlContent = this.markdownToHtml(selectedNode.text || 'No content', selectedNode.fontSize || 14);
        modalContent.innerHTML = htmlContent;

        modal.classList.remove('hidden');

        this.modalEscapeHandler = (e) => {
            if (e.key === 'Escape') {
                this.hideContentModal();
            }
        };
        document.addEventListener('keydown', this.modalEscapeHandler);
    }

    hideContentModal() {
        const modal = document.getElementById('contentModal');
        modal.classList.add('hidden');

        if (this.modalEscapeHandler) {
            document.removeEventListener('keydown', this.modalEscapeHandler);
            this.modalEscapeHandler = null;
        }

        this.resetModalToViewMode();
    }

    toggleModalEditMode() {
        const modalContent = document.getElementById('modalContent');
        
        if (modalContent.querySelector('.modal-edit-textarea')) {
            this.resetModalToViewMode();
        } else {
            this.enterModalEditMode();
        }
    }

    enterModalEditMode() {
        if (this.canvasState.selectedNodes.length !== 1) return;

        const selectedNode = this.canvasState.selectedNodes[0];
        const modalContent = document.getElementById('modalContent');
        const editBtn = document.getElementById('editModalBtn');

        const textarea = document.createElement('textarea');
        textarea.className = 'modal-edit-textarea';
        textarea.value = selectedNode.text || '';
        
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'modal-edit-controls';
        
        const saveBtn = document.createElement('button');
        saveBtn.className = 'modal-save-btn';
        saveBtn.textContent = 'Save Changes';
        saveBtn.addEventListener('click', () => this.saveModalEdit());
        
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'modal-cancel-btn';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', () => this.resetModalToViewMode());
        
        controlsDiv.appendChild(cancelBtn);
        controlsDiv.appendChild(saveBtn);
        
        modalContent.innerHTML = '';
        modalContent.appendChild(textarea);
        modalContent.appendChild(controlsDiv);
        
        editBtn.textContent = '💾';
        editBtn.title = 'Save & Exit Edit Mode';
        
        textarea.focus();
        
        textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.resetModalToViewMode();
            } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                this.saveModalEdit();
            }
        });
    }

    saveModalEdit() {
        const selectedNode = this.canvasState.selectedNodes[0];
        const textarea = document.querySelector('.modal-edit-textarea');
        
        if (selectedNode && textarea) {
            this.canvasState.saveState();
            selectedNode.text = textarea.value;
            this.canvasState.saveToLocalStorage();
            this.resetModalToViewMode();
        }
    }

    resetModalToViewMode() {
        if (this.canvasState.selectedNodes.length !== 1) return;

        const selectedNode = this.canvasState.selectedNodes[0];
        const modalContent = document.getElementById('modalContent');
        const editBtn = document.getElementById('editModalBtn');

        const htmlContent = this.markdownToHtml(selectedNode.text || 'No content', selectedNode.fontSize || 14);
        modalContent.innerHTML = htmlContent;

        editBtn.textContent = '✏️';
        editBtn.title = 'Edit Content';
    }

    markdownToHtml(text, baseFontSize = 14) {
        if (!text || typeof text !== 'string') {
            return '<p>No content</p>';
        }

        const parsed = parseMarkdown(text, baseFontSize);
        let html = '';

        parsed.forEach(item => {
            if (item.type === 'spacing') {
                html += '<br>';
                return;
            }

            if (item.type === 'header') {
                const level = item.level || 1;
                html += `<h${level}>${this.escapeHtml(item.content)}</h${level}>`;
            } else if (item.type === 'list') {
                const content = Array.isArray(item.content)
                    ? this.processInlineFormattingToHtml(item.content)
                    : this.escapeHtml(item.content);
                html += `<li>${content}</li>`;
            } else {
                const content = Array.isArray(item.content)
                    ? this.processInlineFormattingToHtml(item.content)
                    : this.escapeHtml(item.content);
                html += `<p>${content}</p>`;
            }
        });

        html = html.replace(/(<li>.*?<\/li>)+/g, '<ul>$&</ul>');
        return html || '<p>No content</p>';
    }

    processInlineFormattingToHtml(segments) {
        return segments.map(segment => {
            const text = this.escapeHtml(segment.text);
            switch (segment.type) {
                case 'bold':
                    return `<strong>${text}</strong>`;
                case 'italic':
                    return `<em>${text}</em>`;
                case 'code':
                    return `<code>${text}</code>`;
                default:
                    return text;
            }
        }).join('');
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Tooltip and status updates
    updateGenerateIdeasTooltip() {
        if (!this.aiManager) return;
        
        const tooltip = document.getElementById('generateIdeasTooltip');
        const generateBtn = document.getElementById('generateIdeasBtn');
        const expandBtn = document.getElementById('expandContentBtn');
        const generateImageBtn = document.getElementById('generateImageBtn');
        const generateReferenceBtn = document.getElementById('generateReferenceBtn');
        const uploadImageBtn = document.getElementById('uploadImageBtn');
        const contextImageBtn = document.getElementById('contextImageBtn');
        const generateVideoBtn = document.getElementById('generateVideoBtn');
        const downloadImageBtn = document.getElementById('downloadImageBtn');

        if (this.canvasState.selectedNodes.length === 1) {
            const selectedNode = this.canvasState.selectedNodes[0];
            
            // Get canvas element to calculate screen position
            const canvas = document.getElementById('canvas');
            if (!canvas || !tooltip) return;
            
            const rect = canvas.getBoundingClientRect();

            // Position tooltip above the selected node
            const nodeScreenX = rect.left + (selectedNode.x * this.canvasState.scale) + this.canvasState.offsetX;
            const nodeScreenY = rect.top + (selectedNode.y * this.canvasState.scale) + this.canvasState.offsetY;
            const tooltipX = nodeScreenX + (selectedNode.width * this.canvasState.scale) / 2;
            const tooltipY = nodeScreenY - 60; // 60px above the node to accommodate buttons

            tooltip.style.left = `${tooltipX}px`;
            tooltip.style.top = `${tooltipY}px`;
            tooltip.style.transform = 'translateX(-50%)'; // Center horizontally
            tooltip.classList.remove('hidden');

            // Update generate button state
            if (generateBtn) {
                if (this.aiManager.apiKey || this.aiManager.demoMode) {
                    generateBtn.style.display = 'flex';
                    generateBtn.disabled = selectedNode.isGeneratingAI;
                    generateBtn.textContent = selectedNode.isGeneratingAI ? '⏳' : '✨';
                    generateBtn.title = selectedNode.isGeneratingAI ? 'Generating...' : 'Generate Ideas';
                } else {
                    generateBtn.style.display = 'none';
                }
            }

            // Update generate image button
            if (generateImageBtn) {
                if (this.aiManager.replicateApiKey) {
                    generateImageBtn.style.display = 'flex';
                    generateImageBtn.disabled = selectedNode.isGeneratingImage;
                    generateImageBtn.textContent = selectedNode.isGeneratingImage ? '⏳' : '🖼️';
                    generateImageBtn.title = selectedNode.isGeneratingImage ? 'Generating...' : 'Generate Image';
                } else {
                    generateImageBtn.style.display = 'none';
                }
            }

            // Update generate with reference button
            if (generateReferenceBtn) {
                const hasConnectedImages = this.hasConnectedImageNode(selectedNode);
                
                if (this.aiManager.replicateApiKey && hasConnectedImages) {
                    generateReferenceBtn.style.display = 'flex';
                    generateReferenceBtn.disabled = selectedNode.isGeneratingReference;
                    generateReferenceBtn.textContent = selectedNode.isGeneratingReference ? '⏳' : '🎯';
                    generateReferenceBtn.title = selectedNode.isGeneratingReference ? 'Generating...' : 'Generate with Reference (Gen-4)';
                } else {
                    generateReferenceBtn.style.display = 'none';
                }
            }

            // Always show upload image button for single node selection
            if (uploadImageBtn) {
                uploadImageBtn.style.display = 'flex';
                uploadImageBtn.disabled = selectedNode.isUploadingImage;
                uploadImageBtn.textContent = selectedNode.isUploadingImage ? '\u23f3' : '\ud83d\udcc1';
                uploadImageBtn.title = selectedNode.isUploadingImage ? 'Uploading...' : 'Upload Image';
            }

            // Show download image button if node has an image
            if (downloadImageBtn) {
                if (selectedNode.generatedImageUrl) {
                    downloadImageBtn.style.display = 'flex';
                    downloadImageBtn.disabled = false;
                    downloadImageBtn.title = 'Download Image';
                } else {
                    downloadImageBtn.style.display = 'none';
                }
            }

            // Show context image button if replicate API key is available and node has text content
            if (contextImageBtn) {
                // Check if this text node has a connected image node
                const hasConnectedImage = this.hasConnectedImageNode(selectedNode);
                
                if (this.aiManager.replicateApiKey && selectedNode.text && selectedNode.text.trim() !== '' && selectedNode.text.trim() !== 'New Node') {
                    contextImageBtn.style.display = 'flex';
                    contextImageBtn.disabled = selectedNode.isGeneratingContext;
                    contextImageBtn.textContent = selectedNode.isGeneratingContext ? '⏳' : '🎨';
                    if (hasConnectedImage) {
                        contextImageBtn.title = selectedNode.isGeneratingContext ? 'Editing...' : 'Edit Connected Image with Context';
                    } else {
                        contextImageBtn.title = selectedNode.isGeneratingContext ? 'Generating...' : 'Generate & Edit Image';
                    }
                } else {
                    contextImageBtn.style.display = 'none';
                }
            }

            // Show video generation button if replicate API key is available and node has text content
            if (generateVideoBtn) {
                if (this.aiManager.replicateApiKey && selectedNode.text && selectedNode.text.trim() !== '' && selectedNode.text.trim() !== 'New Node') {
                    generateVideoBtn.style.display = 'flex';
                    generateVideoBtn.disabled = selectedNode.isGeneratingVideo;
                    generateVideoBtn.textContent = selectedNode.isGeneratingVideo ? '⏳' : '🎬';
                    
                    // Check if there's a connected image to determine the mode
                    const hasConnectedImage = this.hasConnectedImageNode(selectedNode);
                    if (hasConnectedImage) {
                        generateVideoBtn.title = selectedNode.isGeneratingVideo ? 'Generating...' : 'Generate Video from Connected Image';
                    } else {
                        generateVideoBtn.title = selectedNode.isGeneratingVideo ? 'Generating...' : 'Generate Video from Text';
                    }
                } else {
                    generateVideoBtn.style.display = 'none';
                }
            }

            // Always show expand button for single selection
            if (expandBtn) {
                expandBtn.style.display = 'flex';
            }
        } else {
            if (tooltip) tooltip.classList.add('hidden');
        }
    }

    updateSelectionStatus() {
        const statusElement = document.getElementById('selectionStatus');
        const countElement = document.getElementById('selectionCount');
        const hintElement = document.getElementById('selectionHint');

        if (this.canvasState.selectedNodes.length > 0) {
            statusElement.classList.remove('hidden');
            countElement.textContent = this.canvasState.selectedNodes.length;

            if (this.canvasState.selectedNodes.length > 1) {
                hintElement.classList.remove('hidden');
                hintElement.textContent = 'Select a single node to generate AI ideas';
            } else {
                hintElement.classList.add('hidden');
            }
        } else {
            statusElement.classList.add('hidden');
        }
    }

    // Notifications
    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, duration);
    }

    showProgressNotification(message, models = []) {
        this.hideProgressNotification();

        const progressNotification = document.createElement('div');
        progressNotification.id = 'aiProgressNotification';
        progressNotification.className = 'progress-notification';

        progressNotification.innerHTML = `
            <div class="progress-header">
                <span class="progress-message">${message}</span>
                <button class="progress-close" onclick="this.parentElement.parentElement.remove()">×</button>
            </div>
            <div class="progress-models">
                ${models.map(model => {
                    const modelName = model.split('/').pop() || model;
                    return `<div class="model-status" data-model="${model}">
                        <span class="model-name">${modelName}</span>
                        <span class="model-indicator">⏳</span>
                    </div>`;
                }).join('')}
            </div>
            <div class="progress-summary">
                <span id="progressSummary">Preparing...</span>
            </div>
        `;

        document.body.appendChild(progressNotification);
    }

    updateProgressNotification(completed, total, totalNodes) {
        const progressNotification = document.getElementById('aiProgressNotification');
        if (!progressNotification) return;

        const summaryElement = document.getElementById('progressSummary');
        if (summaryElement) {
            summaryElement.textContent = `${completed}/${total} models completed • ${totalNodes} ideas generated`;
        }
    }

    hideProgressNotification() {
        const progressNotification = document.getElementById('aiProgressNotification');
        if (progressNotification && progressNotification.parentNode) {
            progressNotification.parentNode.removeChild(progressNotification);
        }
    }

    // Export/Import functionality
    exportJSON() {
        try {
            // Export in Obsidian Canvas format
            const obsidianData = {
                nodes: this.canvasState.nodes
                    .filter(node => node && node.id) // Filter out invalid nodes
                    .map(node => ({
                        id: node.id.toString(),
                        type: node.type || "text",
                        text: node.text || '',
                        x: Math.round(node.x || 0),
                        y: Math.round(node.y || 0),
                        width: Math.round(node.width || 360),
                        height: Math.round(node.height || 140)
                    })),
                edges: this.canvasState.connections
                    .filter(conn => {
                        // Filter out invalid connections
                        const fromNodeId = conn.fromNode || conn.from;
                        const toNodeId = conn.toNode || conn.to;
                        return fromNodeId && toNodeId && conn.id;
                    })
                    .map(conn => ({
                        id: conn.id.toString(),
                        fromNode: (conn.fromNode || conn.from).toString(),
                        toNode: (conn.toNode || conn.to).toString(),
                        ...(conn.fromSide && { fromSide: conn.fromSide }),
                        ...(conn.toSide && { toSide: conn.toSide })
                    }))
            };

            const jsonString = JSON.stringify(obsidianData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'canvas-export.canvas';
            a.style.display = 'none';

            document.body.appendChild(a);
            a.click();

            setTimeout(() => {
                if (a.parentNode) {
                    document.body.removeChild(a);
                }
                URL.revokeObjectURL(url);
            }, 100);

            this.showNotification('Obsidian Canvas exported successfully!', 'success');

        } catch (error) {
            console.error('Error during export:', error);
            this.showNotification('Export failed: ' + error.message, 'error');
        }
    }

    importJSON() {
        document.getElementById('importFileInput').click();
    }
    
    updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        if (undoBtn) {
            undoBtn.disabled = !this.canvasState.canUndo();
        }
        if (redoBtn) {
            redoBtn.disabled = !this.canvasState.canRedo();
        }
    }

    async downloadNodeImage(node) {
        if (!node || !node.generatedImageUrl) return;
        
        // Download the image from node.generatedImageUrl as a blob for direct download
        try {
            const response = await fetch(node.generatedImageUrl, {mode: 'cors'});
            if (!response.ok) throw new Error('Failed to fetch image');
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'node-image.png';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                if (a.parentNode) {
                    document.body.removeChild(a);
                }
                URL.revokeObjectURL(url);
            }, 100);
        } catch (err) {
            this.showNotification('Failed to download image: ' + err.message, 'error');
        }
    }

    hasConnectedImageNode(node) {
        // Check if this text node has any connected image nodes
        const connections = this.canvasState.connections;
        const connectedNodeIds = new Set();
        
        // Find all nodes connected to this node (both incoming and outgoing connections)
        connections.forEach(conn => {
            if (conn.from === node.id) {
                connectedNodeIds.add(conn.to);
            }
            if (conn.to === node.id) {
                connectedNodeIds.add(conn.from);
            }
        });
        
        // Check if any connected nodes are image nodes (media reference nodes with images)
        const imageNodes = this.canvasState.nodes.filter(connectedNode => 
            connectedNodeIds.has(connectedNode.id) && 
            connectedNode.isMediaReference && 
            connectedNode.generatedImageUrl
        );
        
        return imageNodes.length > 0;
    }

    // Aspect Ratio Selector
    setupAspectRatioSelector() {
        const aspectRatioSelector = document.getElementById('aspectRatioSelector');
        const generateImageBtn = document.getElementById('generateImageBtn');
        const generateReferenceBtn = document.getElementById('generateReferenceBtn');
        
        if (!aspectRatioSelector || !generateImageBtn || !generateReferenceBtn) return;

        // Setup aspect ratio option buttons
        const aspectRatioOptions = aspectRatioSelector.querySelectorAll('.aspect-ratio-option');
        aspectRatioOptions.forEach(option => {
            option.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Update active state
                aspectRatioOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                
                // Update selected aspect ratio
                this.selectedAspectRatio = option.dataset.ratio;
                
                // Hide selector after selection
                this.hideAspectRatioSelector();
            });
        });

        // Setup hover handlers for image generation buttons
        [generateImageBtn, generateReferenceBtn].forEach(btn => {
            btn.addEventListener('mouseenter', (e) => {
                if (!btn.disabled) {
                    this.showAspectRatioSelector(btn);
                }
            });

            btn.addEventListener('mouseleave', (e) => {
                // Check if mouse is moving towards the selector
                const rect = btn.getBoundingClientRect();
                const selectorRect = aspectRatioSelector.getBoundingClientRect();
                
                // Only hide if not moving towards selector area
                this.aspectRatioTimeout = setTimeout(() => {
                    if (!this.aspectRatioSelectorVisible) return;
                    
                    // Double-check mouse position
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    // If mouse is within selector area, don't hide
                    if (mouseX >= selectorRect.left && mouseX <= selectorRect.right &&
                        mouseY >= selectorRect.top && mouseY <= selectorRect.bottom) {
                        return;
                    }
                    
                    this.hideAspectRatioSelector();
                }, 500); // Increased delay to 500ms
            });
        });

        // Keep selector visible when hovering over it
        aspectRatioSelector.addEventListener('mouseenter', () => {
            // Clear any pending hide timeout
            if (this.aspectRatioTimeout) {
                clearTimeout(this.aspectRatioTimeout);
                this.aspectRatioTimeout = null;
            }
        });

        aspectRatioSelector.addEventListener('mouseleave', (e) => {
            // Only hide if mouse is not moving back to buttons
            const generateImageRect = generateImageBtn.getBoundingClientRect();
            const generateReferenceRect = generateReferenceBtn.getBoundingClientRect();
            
            this.aspectRatioTimeout = setTimeout(() => {
                const mouseX = e.clientX;
                const mouseY = e.clientY;
                
                // Check if mouse is over either button
                const overImageBtn = mouseX >= generateImageRect.left && mouseX <= generateImageRect.right &&
                                   mouseY >= generateImageRect.top && mouseY <= generateImageRect.bottom;
                const overReferenceBtn = mouseX >= generateReferenceRect.left && mouseX <= generateReferenceRect.right &&
                                        mouseY >= generateReferenceRect.top && mouseY <= generateReferenceRect.bottom;
                
                if (!overImageBtn && !overReferenceBtn) {
                    this.hideAspectRatioSelector();
                }
            }, 200); // Shorter delay when leaving selector
        });
    }

    showAspectRatioSelector(button) {
        if (this.aspectRatioTimeout) {
            clearTimeout(this.aspectRatioTimeout);
            this.aspectRatioTimeout = null;
        }

        const aspectRatioSelector = document.getElementById('aspectRatioSelector');
        if (!aspectRatioSelector) return;

        // Position the selector above the button with minimal gap
        const buttonRect = button.getBoundingClientRect();
        aspectRatioSelector.style.left = buttonRect.left + 'px';
        aspectRatioSelector.style.top = (buttonRect.top - 50) + 'px'; // Reduced gap from 60px to 50px

        aspectRatioSelector.classList.remove('hidden');
        this.aspectRatioSelectorVisible = true;
    }

    hideAspectRatioSelector() {
        const aspectRatioSelector = document.getElementById('aspectRatioSelector');
        if (!aspectRatioSelector) return;

        aspectRatioSelector.classList.add('hidden');
        this.aspectRatioSelectorVisible = false;

        if (this.aspectRatioTimeout) {
            clearTimeout(this.aspectRatioTimeout);
            this.aspectRatioTimeout = null;
        }
    }

    getSelectedAspectRatio() {
        return this.selectedAspectRatio;
    }
} 


---
File: /infinite_canvas_v5/.gitignore
---

node_modules/
dist/

# Environment variables (contains sensitive API keys)
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db


---
File: /infinite_canvas_v5/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags -->
    <title>HumOS Canvas - Your Personal AI Integration Framework</title>
    <meta name="title" content="HumOS Canvas - Your Personal AI Integration Framework">
    <meta name="description" content="HumOS Canvas: Your Personal Interface for Enhanced AI Collaboration. Create, connect, and explore ideas with AI-powered mind mapping and infinite canvas visualization.">
    <meta name="keywords" content="AI collaboration, mind mapping, infinite canvas, HumOS, AI integration, visual thinking, idea generation, knowledge management">
    <meta name="author" content="HumOS">
    <meta name="robots" content="index, follow">

    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="dist/favicon.svg">
    <link rel="icon" type="image/svg+xml" href="public/humos-icon.svg" sizes="any">
    <link rel="apple-touch-icon" href="public/humos-icon.svg">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://humos-canvas.vercel.app/">
    <meta property="og:title" content="HumOS Canvas - Your Personal AI Integration Framework">
    <meta property="og:description" content="HumOS Canvas: Your Personal Interface for Enhanced AI Collaboration. Create, connect, and explore ideas with AI-powered mind mapping and infinite canvas visualization.">
    <meta property="og:image" content="public/image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:type" content="image/png">
    <meta property="og:site_name" content="HumOS Canvas">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://humos-canvas.vercel.app/">
    <meta property="twitter:title" content="HumOS Canvas - Your Personal AI Integration Framework">
    <meta property="twitter:description" content="HumOS Canvas: Your Personal Interface for Enhanced AI Collaboration. Create, connect, and explore ideas with AI-powered mind mapping and infinite canvas visualization.">
    <meta property="twitter:image" content="public/image.png">
    <meta property="twitter:image:alt" content="HumOS Canvas - AI-powered mind mapping interface">

    <!-- Additional SEO -->
    <meta name="theme-color" content="#1a1a1a">
    <meta name="msapplication-TileColor" content="#1a1a1a">
    <meta name="application-name" content="HumOS Canvas">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "HumOS Canvas",
      "description": "Your Personal Interface for Enhanced AI Collaboration. Create, connect, and explore ideas with AI-powered mind mapping and infinite canvas visualization.",
      "url": "https://humos-canvas.vercel.app/",
      "applicationCategory": "ProductivityApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "creator": {
        "@type": "Organization",
        "name": "HumOS"
      }
    }
    </script>

    <!-- Microsoft Clarity Analytics -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "s5ui66hidb");
    </script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="app-container">
        <!-- Canvas element for drawing -->
        <canvas id="canvas"></canvas>
        

        <!-- Hidden file input for import -->
        <input type="file" id="importFileInput" accept=".json" style="display: none;">
        
        <!-- Hidden file input for image uploads -->
        <input type="file" id="uploadImageInput" accept="image/*" style="display: none;">

        <!-- Generate Ideas tooltip (appears above selected nodes) -->
        <div id="generateIdeasTooltip" class="generate-ideas-tooltip hidden">
            <button id="expandContentBtn" class="expand-content-btn" title="Expand Content">⛶</button>
            <button id="generateIdeasBtn" class="generate-ideas-btn" title="Generate Ideas">✨</button>
            <button id="generateImageBtn" class="generate-ideas-btn" title="Generate Image">🖼️</button>
            <button id="generateReferenceBtn" class="generate-ideas-btn" title="Generate with Reference (Gen-4)">🎯</button>
            <button id="downloadImageBtn" class="generate-ideas-btn" title="Download Image">⬇️</button>
            <button id="contextImageBtn" class="generate-ideas-btn" title="Edit Image with Context">🎨</button>
            <button id="generateVideoBtn" class="generate-ideas-btn" title="Generate Video">🎬</button>
        </div>

        <!-- Aspect Ratio Selector (appears when hovering over image generation buttons) -->
        <div id="aspectRatioSelector" class="aspect-ratio-selector hidden">
            <div class="aspect-ratio-header">Aspect Ratio</div>
            <div class="aspect-ratio-options">
                <button class="aspect-ratio-option active" data-ratio="1:1">1:1</button>
                <button class="aspect-ratio-option" data-ratio="16:9">16:9</button>
                <button class="aspect-ratio-option" data-ratio="9:16">9:16</button>
            </div>
        </div>

        <!-- Content Expansion Modal -->
        <div id="contentModal" class="content-modal hidden">
            <div class="modal-backdrop"></div>
            <div class="modal-container">
                <div class="modal-header">
                    <h3 id="modalTitle">Node Content</h3>
                    <div class="modal-header-buttons">
                        <button id="editModalBtn" class="edit-modal-btn" title="Edit Content">✏️</button>
                        <button id="closeModalBtn" class="close-modal-btn">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <div id="modalContent" class="modal-content-text"></div>
                </div>
            </div>
        </div>

        <!-- Selection status indicator -->
        <div id="selectionStatus" class="selection-status hidden">
            <span id="selectionCount">0</span> nodes selected
            <small id="selectionHint" class="selection-hint hidden">Select a single node to generate AI ideas</small>
        </div>
        
        <!-- Canvas navigation controls -->
        <div class="canvas-controls">
            <button id="zoomInBtn" class="control-btn"><img src="public/icons/zoom-in.svg" alt="Zoom In" class="control-icon"></button>
            <button id="zoomOutBtn" class="control-btn"><img src="public/icons/zoom-out.svg" alt="Zoom Out" class="control-icon"></button>
            <button id="resetViewBtn" class="control-btn"><img src="public/icons/reset-view.svg" alt="Reset View" class="control-icon"></button>
            <div class="control-separator"></div>
            <button id="undoBtn" class="control-btn" title="Undo"><img src="public/icons/undo.svg" alt="Undo" class="control-icon"></button>
            <button id="redoBtn" class="control-btn" title="Redo"><img src="public/icons/redo.svg" alt="Redo" class="control-icon"></button>
            <div class="control-separator"></div>
            <button id="fontSizeDecreaseBtn" class="control-btn" title="Decrease Font Size"><img src="public/icons/font-decrease.svg" alt="Decrease Font Size" class="control-icon"></button>
            <button id="fontSizeIncreaseBtn" class="control-btn" title="Increase Font Size"><img src="public/icons/font-increase.svg" alt="Increase Font Size" class="control-icon"></button>
        </div>

        <!-- Navigation help -->
        <div class="navigation-help">
            <div class="help-item">🖱️ Right-click + drag to pan</div>
            <div class="help-item">⌨️ Space + drag to pan</div>
            <div class="help-item">👆 Two-finger scroll to pan</div>
            <div class="help-item">🤏 Pinch to zoom</div>
            <div class="help-item">🖱️ Scroll to zoom</div>
            <div class="help-item">📋 Ctrl+C to copy nodes</div>
            <div class="help-item">📋 Ctrl+V to paste nodes</div>
        </div>

        <!-- Model Selector Panel -->
        <div class="model-selector-panel" id="modelSelectorPanel">
            <div class="panel-header" id="modelPanelHeader">
                <div class="drag-handle" id="dragHandle" title="Drag to move panel">
                    <span class="drag-icon">⋮⋮</span>
                </div>
                <h5>🤖 AI Models</h5>
                <div class="header-controls">
                    <span id="activeModelCount" class="active-count">0 active</span>
                    <button id="toggleModelsBtn" class="toggle-btn" title="Show/Hide Models">▲</button>
                </div>
            </div>
            <div id="modelCheckboxesContainer" class="panel-content">
                <!-- Active models will be dynamically inserted here -->
            </div>
            <div class="panel-footer">
                <button id="configureBtn" class="manage-btn" title="Configure App & AI Models">⚙️ Configure</button>
            </div>
        </div>
    </div>
    
    <script type="module" src="main.js"></script>
</body>
</html>



---
File: /infinite_canvas_v5/main.js
---

// Entry point for the HumOS Canvas application
import { InfiniteCanvas } from './src/InfiniteCanvasSimple.js';
import './style.css';

// Initialize the application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.canvasApp = new InfiniteCanvas('canvas');
    console.log('HumOS Canvas initialized with modular structure');
});


---
File: /infinite_canvas_v5/package-lock.json
---

{
  "name": "humos_canvas",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "humos_canvas",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "cors": "^2.8.5",
        "express": "^5.1.0",
        "node-fetch": "^3.3.2",
        "openai": "^5.0.1"
      },
      "devDependencies": {
        "vite": "^4.5.3"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.18.20.tgz",
      "integrity": "sha512-fyi7TDI/ijKKNZTUJAQqiG5T7YjJXgnzkURqmGj13C6dCqckZBLdl4h7bkhHt/t0WP+zO9/zwroDvANaOqO5Sw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.18.20.tgz",
      "integrity": "sha512-Nz4rJcchGDtENV0eMKUNa6L12zz2zBDXuhj/Vjh18zGqB44Bi7MBMSXjgunJgjRhCmKOjnPuZp4Mb6OKqtMHLQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.18.20.tgz",
      "integrity": "sha512-8GDdlePJA8D6zlZYJV/jnrRAi6rOiNaCC/JclcXpB+KIuvfBN4owLtgzY2bsxnx666XjJx2kDPUmnTtR8qKQUg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.18.20.tgz",
      "integrity": "sha512-bxRHW5kHU38zS2lPTPOyuyTm+S+eobPUnTNkdJEfAddYgEcll4xkT8DB9d2008DtTbl7uJag2HuE5NZAZgnNEA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.18.20.tgz",
      "integrity": "sha512-pc5gxlMDxzm513qPGbCbDukOdsGtKhfxD1zJKXjCCcU7ju50O7MeAZ8c4krSJcOIJGFR+qx21yMMVYwiQvyTyQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.18.20.tgz",
      "integrity": "sha512-yqDQHy4QHevpMAaxhhIwYPMv1NECwOvIpGCZkECn8w2WFHXjEwrBn3CeNIYsibZ/iZEUemj++M26W3cNR5h+Tw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.18.20.tgz",
      "integrity": "sha512-tgWRPPuQsd3RmBZwarGVHZQvtzfEBOreNuxEMKFcd5DaDn2PbBxfwLcj4+aenoh7ctXcbXmOQIn8HI6mCSw5MQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.18.20.tgz",
      "integrity": "sha512-/5bHkMWnq1EgKr1V+Ybz3s1hWXok7mDFUMQ4cG10AfW3wL02PSZi5kFpYKrptDsgb2WAJIvRcDm+qIvXf/apvg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.18.20.tgz",
      "integrity": "sha512-2YbscF+UL7SQAVIpnWvYwM+3LskyDmPhe31pE7/aoTMFKKzIc9lLbyGUpmmb8a8AixOL61sQ/mFh3jEjHYFvdA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.18.20.tgz",
      "integrity": "sha512-P4etWwq6IsReT0E1KHU40bOnzMHoH73aXp96Fs8TIT6z9Hu8G6+0SHSw9i2isWrD2nbx2qo5yUqACgdfVGx7TA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.18.20.tgz",
      "integrity": "sha512-nXW8nqBTrOpDLPgPY9uV+/1DjxoQ7DoB2N8eocyq8I9XuqJ7BiAMDMf9n1xZM9TgW0J8zrquIb/A7s3BJv7rjg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.18.20.tgz",
      "integrity": "sha512-d5NeaXZcHp8PzYy5VnXV3VSd2D328Zb+9dEq5HE6bw6+N86JVPExrA6O68OPwobntbNJ0pzCpUFZTo3w0GyetQ==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.18.20.tgz",
      "integrity": "sha512-WHPyeScRNcmANnLQkq6AfyXRFr5D6N2sKgkFo2FqguP44Nw2eyDlbTdZwd9GYk98DZG9QItIiTlFLHJHjxP3FA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.18.20.tgz",
      "integrity": "sha512-WSxo6h5ecI5XH34KC7w5veNnKkju3zBRLEQNY7mv5mtBmrP/MjNBCAlsM2u5hDBlS3NGcTQpoBvRzqBcRtpq1A==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.18.20.tgz",
      "integrity": "sha512-+8231GMs3mAEth6Ja1iK0a1sQ3ohfcpzpRLH8uuc5/KVDFneH6jtAJLFGafpzpMRO6DzJ6AvXKze9LfFMrIHVQ==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.18.20.tgz",
      "integrity": "sha512-UYqiqemphJcNsFEskc73jQ7B9jgwjWrSayxawS6UVFZGWrAAtkzjxSqnoclCXxWtfwLdzU+vTpcNYhpn43uP1w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.18.20.tgz",
      "integrity": "sha512-iO1c++VP6xUBUmltHZoMtCUdPlnPGdBom6IrO4gyKPFFVBKioIImVooR5I83nTew5UOYrk3gIJhbZh8X44y06A==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.18.20.tgz",
      "integrity": "sha512-e5e4YSsuQfX4cxcygw/UCPIEP6wbIL+se3sxPdCiMbFLBWu0eiZOJ7WoD+ptCLrmjZBK1Wk7I6D/I3NglUGOxg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.18.20.tgz",
      "integrity": "sha512-kDbFRFp0YpTQVVrqUd5FTYmWo45zGaXe0X8E1G/LKFC0v8x0vWrhOWSLITcCn63lmZIxfOMXtCfti/RxN/0wnQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.18.20.tgz",
      "integrity": "sha512-ddYFR6ItYgoaq4v4JmQQaAI5s7npztfV4Ag6NrhiaW0RrnOXqBkgwZLofVTlq1daVTQNhtI5oieTvkRPfZrePg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.18.20.tgz",
      "integrity": "sha512-Wv7QBi3ID/rROT08SABTS7eV4hX26sVduqDOTe1MvGMjNd3EjOz4b7zeexIR62GTIEKrfJXKL9LFxTYgkyeu7g==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.18.20.tgz",
      "integrity": "sha512-kTdfRcSiDfQca/y9QIkng02avJ+NCaQvrMejlsB3RRv5sE9rRoeBPISaZpKxHELzRxZyLvNts1P27W3wV+8geQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/body-parser": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.0.tgz",
      "integrity": "sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.0",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.6.3",
        "on-finished": "^2.4.1",
        "qs": "^6.14.0",
        "raw-body": "^3.0.0",
        "type-is": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/content-disposition": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz",
      "integrity": "sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/data-uri-to-buffer": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/data-uri-to-buffer/-/data-uri-to-buffer-4.0.1.tgz",
      "integrity": "sha512-0R9ikRb668HB7QDxT1vkpuUBtqc53YyAwMwGeUFKRojY/NWKvdZ+9UYtRfGmhqNbRkTSVpMbmyhXipFFv2cb/A==",
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow=="
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.18.20",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.18.20.tgz",
      "integrity": "sha512-ceqxoedUrcayh7Y7ZX6NdbbDzGROiyVBgC4PriJThBKSVPWnnFHZAkfI1lJT8QFkOwH4qOS2SJkS4wvpGl8BpA==",
      "dev": true,
      "hasInstallScript": true,
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/android-arm": "0.18.20",
        "@esbuild/android-arm64": "0.18.20",
        "@esbuild/android-x64": "0.18.20",
        "@esbuild/darwin-arm64": "0.18.20",
        "@esbuild/darwin-x64": "0.18.20",
        "@esbuild/freebsd-arm64": "0.18.20",
        "@esbuild/freebsd-x64": "0.18.20",
        "@esbuild/linux-arm": "0.18.20",
        "@esbuild/linux-arm64": "0.18.20",
        "@esbuild/linux-ia32": "0.18.20",
        "@esbuild/linux-loong64": "0.18.20",
        "@esbuild/linux-mips64el": "0.18.20",
        "@esbuild/linux-ppc64": "0.18.20",
        "@esbuild/linux-riscv64": "0.18.20",
        "@esbuild/linux-s390x": "0.18.20",
        "@esbuild/linux-x64": "0.18.20",
        "@esbuild/netbsd-x64": "0.18.20",
        "@esbuild/openbsd-x64": "0.18.20",
        "@esbuild/sunos-x64": "0.18.20",
        "@esbuild/win32-arm64": "0.18.20",
        "@esbuild/win32-ia32": "0.18.20",
        "@esbuild/win32-x64": "0.18.20"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow=="
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/express/-/express-5.1.0.tgz",
      "integrity": "sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.2.0",
        "content-disposition": "^1.0.0",
        "content-type": "^1.0.5",
        "cookie": "^0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "finalhandler": "^2.1.0",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "merge-descriptors": "^2.0.0",
        "mime-types": "^3.0.0",
        "on-finished": "^2.4.1",
        "once": "^1.4.0",
        "parseurl": "^1.3.3",
        "proxy-addr": "^2.0.7",
        "qs": "^6.14.0",
        "range-parser": "^1.2.1",
        "router": "^2.2.0",
        "send": "^1.1.0",
        "serve-static": "^2.2.0",
        "statuses": "^2.0.1",
        "type-is": "^2.0.1",
        "vary": "^1.1.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/fetch-blob": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/fetch-blob/-/fetch-blob-3.2.0.tgz",
      "integrity": "sha512-7yAQpD2UMJzLi1Dqv7qFYnPbaPx7ZfFK6PiIxQ4PfkGPyNyl2Ugx+a/umUonmKqjhM4DnfbMvdX6otXq83soQQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/jimmywarting"
        },
        {
          "type": "paypal",
          "url": "https://paypal.me/jimmywarting"
        }
      ],
      "dependencies": {
        "node-domexception": "^1.0.0",
        "web-streams-polyfill": "^3.0.3"
      },
      "engines": {
        "node": "^12.20 || >= 14.13"
      }
    },
    "node_modules/finalhandler": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.0.tgz",
      "integrity": "sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/formdata-polyfill": {
      "version": "4.0.10",
      "resolved": "https://registry.npmjs.org/formdata-polyfill/-/formdata-polyfill-4.0.10.tgz",
      "integrity": "sha512-buewHzMvYL29jdeQTVILecSaZKnt/RJWjoZCF5OW60Z67/GmSLBkOFM7qh1PI3zFNtJbaZL5eQu1vLfazOwj4g==",
      "dependencies": {
        "fetch-blob": "^3.1.2"
      },
      "engines": {
        "node": ">=12.20.0"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/http-errors/node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ=="
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.1.tgz",
      "integrity": "sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==",
      "dependencies": {
        "mime-db": "^1.54.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-domexception": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/node-domexception/-/node-domexception-1.0.0.tgz",
      "integrity": "sha512-/jKZoMpw0F8GRwl4/eLROPA3cfcXtLApP0QzLmUT/HuPCZWyB7IY9ZrMeKw2O/nFIqPQB3PVM9aYm0F312AXDQ==",
      "deprecated": "Use your platform's native DOMException instead",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/jimmywarting"
        },
        {
          "type": "github",
          "url": "https://paypal.me/jimmywarting"
        }
      ],
      "engines": {
        "node": ">=10.5.0"
      }
    },
    "node_modules/node-fetch": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-3.3.2.tgz",
      "integrity": "sha512-dRB78srN/l6gqWulah9SrxeYnxeddIG30+GOqK/9OlLVyLg3HPnr6SqOWTWOXKRwC2eGYCkZ59NNuSgvSrpgOA==",
      "dependencies": {
        "data-uri-to-buffer": "^4.0.0",
        "fetch-blob": "^3.1.4",
        "formdata-polyfill": "^4.0.10"
      },
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/node-fetch"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/openai": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/openai/-/openai-5.0.1.tgz",
      "integrity": "sha512-Do6vxhbDv7cXhji/4ct1lrpZYMAOmjYbhyA9LJTuG7OfpbWMpuS+EIXkRT7R+XxpRB1OZhU/op4FU3p3uxU6gw==",
      "bin": {
        "openai": "bin/cli"
      },
      "peerDependencies": {
        "ws": "^8.18.0",
        "zod": "^3.23.8"
      },
      "peerDependenciesMeta": {
        "ws": {
          "optional": true
        },
        "zod": {
          "optional": true
        }
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
      "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true
    },
    "node_modules/postcss": {
      "version": "8.5.4",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.4.tgz",
      "integrity": "sha512-QSa9EBe+uwlGTFmHsPKokv3B/oEMQZxfqW0QqNCyhpa6mB1afzulwn8hihglqAb2pOw+BJgNlmXQ8la2VeHB7w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
      "integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.6.3",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/rollup": {
      "version": "3.29.5",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-3.29.5.tgz",
      "integrity": "sha512-GVsDdsbJzzy4S/v3dqWPJ7EfvZJfCHiDqe80IyrF59LYuP+e6U1LJoUqeuqRbwAWoMNoXivMNeNAOf5E22VA1w==",
      "dev": true,
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=14.18.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/router": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
      "dependencies": {
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/send": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/send/-/send-1.2.0.tgz",
      "integrity": "sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==",
      "dependencies": {
        "debug": "^4.3.5",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "mime-types": "^3.0.1",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/serve-static": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.0.tgz",
      "integrity": "sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.2.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/type-is": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/vite": {
      "version": "4.5.3",
      "resolved": "https://registry.npmjs.org/vite/-/vite-4.5.3.tgz",
      "integrity": "sha512-kQL23kMeX92v3ph7IauVkXkikdDRsYMGTVl5KY2E9OY4ONLvkHf04MDTbnfo6NKxZiDLWzVpP5oTa8hQD8U3dg==",
      "dev": true,
      "dependencies": {
        "esbuild": "^0.18.10",
        "postcss": "^8.4.27",
        "rollup": "^3.27.1"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      },
      "peerDependencies": {
        "@types/node": ">= 14",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/web-streams-polyfill": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/web-streams-polyfill/-/web-streams-polyfill-3.3.3.tgz",
      "integrity": "sha512-d2JWLCivmZYTSIoge9MsgFCZrt571BikcWGYkjC1khllbTeDlGqZ2D8vD8E/lJa8WGWbb7Plm8/XJYV7IJHZZw==",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ=="
    }
  }
}



---
File: /infinite_canvas_v5/package.json
---

{
  "name": "humos_canvas",
  "version": "1.0.0",
  "description": "HumOS Canvas - AI-powered mind mapping and brainstorming tool with infinite canvas workspace",
  "main": "main.js",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "vite": "^4.5.3"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "node-fetch": "^3.3.2",
    "openai": "^5.0.1"
  }
}



---
File: /infinite_canvas_v5/README.md
---

# HumOS Canvas - Your Personal AI Integration Framework

**Your Personal Interface for Enhanced AI Collaboration**

![HumOS Canvas Interface](public/image.png)

HumOS Canvas is a modern infinite canvas application with AI-powered idea generation, supporting multiple AI providers. Built with a clean, modular architecture for maintainability and extensibility.

## Features

- **Infinite Canvas**: Pan, zoom, and navigate a limitless workspace
- **Node Management**: Create, edit, resize, and delete nodes with visual feedback
- **Smart Connections**: Link nodes with visual connections (Ctrl/Cmd + click and drag)
- **AI Integration**: Generate connected ideas using multiple AI models simultaneously
- **Multi-Provider Support**: Works with OpenAI, OpenRouter, local models, and any OpenAI-compatible API
- **Demo Mode**: Free tier using Groq API with powerful models like Llama 3.3 70B
- **Interactive UI**: Floating tooltip buttons appear above selected nodes for quick actions
- **Model Management**: Drag-and-drop model selector panel with active/inactive model organization
- **Undo/Redo**: Full history management with 50-state memory
- **Auto-save**: Persistent local storage with automatic recovery
- **Import/Export**: JSON-based data exchange with validation
- **Media Support**: Image generation, upload, and video generation capabilities
- **Markdown Rendering**: Rich text formatting with live preview

## Architecture

HumOS Canvas features a **modular, SOLID-principled architecture** that replaced a monolithic 3944-line file with focused, maintainable modules:

### Core Modules

- **`CanvasState.js`** (~500 lines) - Data management and persistence
  - Canvas data (nodes, connections, selections)
  - History management for undo/redo
  - Spatial grid optimization for performance
  - Copy/paste functionality
  - Local storage persistence

- **`AIManager.js`** (~800 lines) - AI integration and processing
  - Multi-provider API management (OpenAI, OpenRouter, local models)
  - Demo mode with free Groq API integration
  - Parallel AI generation across multiple models
  - Image and video generation capabilities
  - Provider detection and error handling

- **`UIManager.js`** (~900 lines) - User interface and interactions
  - Modal dialogs (API config, content expansion)
  - Floating tooltip system with smart positioning
  - Drag-and-drop model selector panel
  - Notification system and progress tracking
  - Import/export functionality

- **`InputHandler.js`** (~600 lines) - User input and interactions
  - Mouse and keyboard event handling
  - Node selection, dragging, and resizing
  - Connection creation and management
  - Canvas navigation (pan, zoom, reset)
  - Keyboard shortcuts and hotkeys

- **`InfiniteCanvasSimple.js`** (~150 lines) - Main coordinator
  - Module initialization and orchestration
  - Event binding and lifecycle management
  - Public API for external integrations
  - Maintains backward compatibility

### Supporting Modules

- **`canvasRenderer.js`** - High-performance canvas rendering with viewport culling
- **`markdownParser.js`** - Markdown parsing and text processing
- **`markdownRenderer.js`** - Canvas-based markdown rendering
- **`aiService.js`** - Low-level AI API communication

### Benefits of Modular Architecture

- **Single Responsibility**: Each module has one clear purpose
- **Maintainability**: Changes are isolated to specific areas
- **Testability**: Individual modules can be tested independently  
- **Extensibility**: New features can be added without affecting existing code
- **Performance**: Viewport culling and spatial indexing for smooth interaction
- **Developer Experience**: Easier debugging and code navigation

## About HumOS

HumOS (Human-AI Integration Framework) aims to enhance human capabilities, foster self-understanding, and contribute to solving complex challenges through continuous learning and collaboration. The system is designed around the "Synergy Loop" - a continuous cycle of information flow and co-creation between human and AI.

### Icon Design Philosophy

The HumOS icon represents the core philosophy of human-AI integration:

- **Left side (Blue gradient)**: Human consciousness, brain patterns, and cognitive processes
- **Right side (Gold gradient)**: AI neural networks, processing capabilities, and machine learning
- **Central synergy core (White)**: The integration point where human and AI capabilities merge and amplify each other
- **Flow lines (Dashed curves)**: Continuous data exchange, learning loops, and collaborative information flow
- **Enhancement nodes (Corner circles)**: Augmented capabilities and expanded potential emerging from the integration
- **Connection lines**: The network effect of human-AI collaboration extending capabilities in all directions

The design symbolizes the transformation from separate human and AI systems to an integrated framework where both enhance each other's capabilities.

## AI Provider Configuration

The application supports multiple AI providers through a flexible configuration system:

### Supported Providers

- **Demo Mode**: Free Groq API with Llama 3.3 70B, Qwen QWQ 32B, and Gemma2 9B (recommended for getting started)
- **OpenAI**: `https://api.openai.com/v1` - GPT models
- **OpenRouter**: `https://openrouter.ai/api/v1` - Access to hundreds of models from different providers
- **Local Models**: `http://localhost:1234/v1` - LM Studio, Ollama with OpenAI compatibility
- **Custom APIs**: Any OpenAI-compatible endpoint

### Setup

1. Click the "⚙️ Configure" button
2. Choose Demo Mode (free) or enter your API configuration
3. Select which models to activate from the available list
4. Use the drag-and-drop model panel to manage active models

### OpenRouter Setup (Recommended)

For maximum model variety and cost-effectiveness:

1. Sign up at [openrouter.ai](https://openrouter.ai)
2. Get your API key from the dashboard
3. Use base URL: `https://openrouter.ai/api/v1`
4. Access hundreds of models from OpenAI, Anthropic, Google, Meta, and more

## Development

### Prerequisites

- Node.js 18+
- npm

### Setup

```bash
# Install dependencies
npm install

# Set up environment variables (optional - demo mode works without API keys)
cp .env.example .env
# Edit .env and add your Groq API key for enhanced demo mode

# Start development server
npm run dev

# Build for production
npm run build

# Preview production build
npm run preview
```

### Environment Variables

The application includes a free demo mode, but you can enhance it with your own API keys:

1. Copy `.env.example` to `.env`
2. Get a free Groq API key from [console.groq.com/keys](https://console.groq.com/keys)
3. Add your API key to the `.env` file:

```env
VITE_GROQ_API_KEY=your_actual_groq_api_key_here
```

**Note**: The `.env` file is automatically ignored by git to keep your API keys secure.

### Project Structure

```
src/
├── InfiniteCanvasSimple.js    # Main coordinator class
├── CanvasState.js            # Data management & persistence
├── AIManager.js              # AI integration & processing  
├── UIManager.js              # User interface & interactions
├── InputHandler.js           # Input handling & events
├── canvasRenderer.js         # High-performance rendering
├── markdownParser.js         # Markdown text processing
├── markdownRenderer.js       # Canvas markdown rendering
└── aiService.js              # AI API communication

main.js                       # Application entry point
index.html                    # HTML template
style.css                     # Styling and UI components
package.json                  # Dependencies and scripts
```

## Usage

### Basic Operations

- **Create Node**: Double-click empty space
- **Edit Node**: Double-click a node to edit text (supports Markdown)
- **Select Node**: Click a node - tooltip buttons will appear above it
- **Move Node**: Drag a selected node
- **Resize Node**: Drag the resize handles on selected nodes
- **Connect Nodes**: Ctrl/Cmd + click and drag from connection points (blue circles)
- **Delete Node**: Select node(s) and press Delete/Backspace

### Canvas Navigation

- **Pan**: Right-click + drag, Space + drag, or two-finger scroll
- **Zoom**: Mouse wheel or zoom buttons
- **Reset View**: Click the reset view button (⌂)
- **Font Size**: Use +/- buttons to adjust global font size

### AI Features

1. **Select a node** containing your central idea
2. **Tooltip buttons appear** above the selected node:
   - **✨ Generate Ideas** - Create connected AI-generated concepts
   - **⛶ Expand Content** - View full content in modal dialog
   - **🖼️ Generate Image** - Create images from text (requires Replicate API)
   - **📁 Upload Image** - Add images to nodes
   - **🎨 Edit Image** - Modify images with AI (requires Replicate API)
   - **🎬 Generate Video** - Create videos from text (requires Replicate API)
3. **Multiple models** can generate ideas simultaneously
4. **New nodes** are created and automatically connected

### Keyboard Shortcuts

- **Ctrl/Cmd + C** - Copy selected nodes
- **Ctrl/Cmd + V** - Paste nodes
- **Ctrl/Cmd + Z** - Undo
- **Ctrl/Cmd + Y** - Redo
- **Delete/Backspace** - Delete selected nodes
- **Escape** - Clear selection or close modals

## Technical Details

### Dependencies

- **Vite**: Modern build tool and dev server
- **ES6 Modules**: Modern JavaScript module system
- **Canvas API**: High-performance 2D rendering
- **Local Storage**: Data persistence
- **Fetch API**: HTTP requests for AI services

### Performance Features

- **Viewport Culling**: Only renders visible nodes for smooth performance
- **Spatial Grid**: Optimized node lookup and collision detection
- **Efficient Rendering**: Minimized canvas redraws and optimized drawing operations
- **Memory Management**: Proper cleanup of video elements and event listeners

### Features Implemented

- ✅ **Modular Architecture**: Clean separation of concerns with SOLID principles
- ✅ **Vite-based Build System**: Fast development and optimized production builds
- ✅ **Multi-Provider AI Integration**: Support for multiple AI services
- ✅ **Demo Mode**: Free tier with powerful models (Groq API)
- ✅ **Interactive UI**: Floating tooltips and drag-and-drop panels
- ✅ **Rich Media Support**: Images, videos, and markdown rendering
- ✅ **Performance Optimization**: Viewport culling and spatial indexing
- ✅ **Data Persistence**: Auto-save with import/export functionality
- ✅ **Error Handling**: Comprehensive error management and user feedback
- ✅ **Responsive Design**: Works on desktop and tablet devices

### Browser Compatibility

Modern browsers with ES6 module support required:
- Chrome 61+
- Firefox 60+
- Safari 11+
- Edge 16+

## Contributing

We welcome contributions! The modular architecture makes it easy to:

- Add new AI providers in `AIManager.js`
- Enhance UI components in `UIManager.js`
- Improve rendering in `canvasRenderer.js`
- Add new input methods in `InputHandler.js`

## License

MIT License


---
File: /infinite_canvas_v5/replicate-proxy.js
---

import express from 'express';
import fetch from 'node-fetch';
import cors from 'cors';

const app = express();
app.use(express.json());
app.use(cors()); // Allow all origins for dev

// Helper function to get the appropriate aspect ratio format for different models
function getModelAspectRatio(model, requestedAspectRatio) {
    // Map of models to their supported aspect ratio formats
    const modelAspectRatioMaps = {
        'recraft-ai/recraft-v3': {
            '1:1': '1:1',
            '16:9': '16:9', 
            '9:16': '9:16'
        },
        'google/imagen-4': {
            '1:1': '1:1',
            '16:9': '16:9',
            '9:16': '9:16'
        },
        'bytedance/seedream-3': {
            '1:1': '1:1',
            '16:9': '16:9',
            '9:16': '9:16'
        }
    };

    const modelMap = modelAspectRatioMaps[model];
    if (modelMap && modelMap[requestedAspectRatio]) {
        return modelMap[requestedAspectRatio];
    }
    
    // Default fallback
    return '1:1';
}

// Helper function to get the appropriate model endpoint
function getModelEndpoint(model) {
    const endpoints = {
        'recraft-ai/recraft-v3': 'https://api.replicate.com/v1/models/recraft-ai/recraft-v3/predictions',
        'google/imagen-4': 'https://api.replicate.com/v1/models/google/imagen-4/predictions',
        'bytedance/seedream-3': 'https://api.replicate.com/v1/models/bytedance/seedream-3/predictions'
    };
    
    return endpoints[model] || endpoints['bytedance/seedream-3']; // fallback
}

// Helper function to create model-specific input parameters
function createModelInput(model, prompt, aspectRatio) {
    const mappedAspectRatio = getModelAspectRatio(model, aspectRatio);
    
    switch (model) {
        case 'recraft-ai/recraft-v3':
            return {
                prompt,
                aspect_ratio: mappedAspectRatio,
                style: 'any'
            };
        
        case 'google/imagen-4':
            return {
                prompt,
                aspect_ratio: mappedAspectRatio,
                safety_filter_level: 'block_medium_and_above',
                output_format: 'png'
            };
        
        case 'bytedance/seedream-3':
        default:
            return {
                prompt,
                size: 'regular',
                aspect_ratio: mappedAspectRatio,
                guidance_scale: 3.5
            };
    }
}

app.post('/api/replicate-image', async (req, res) => {
    const { prompt, replicateApiKey, model = 'bytedance/seedream-3', aspectRatio = '1:1' } = req.body;
    if (!prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing prompt or replicateApiKey' });
    }
    
    const endpoint = getModelEndpoint(model);
    const input = createModelInput(model, prompt, aspectRatio);
    
    const body = { input };
    
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${replicateApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        res.status(response.status).json(data);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Context image editing endpoint
app.post('/api/replicate-context', async (req, res) => {
    const { imageUrl, prompt, replicateApiKey, aspectRatio = 'match_input_image' } = req.body;
    if (!imageUrl || !prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing imageUrl, prompt, or replicateApiKey' });
    }
    
    const endpoint = 'https://api.replicate.com/v1/models/black-forest-labs/flux-kontext-pro/predictions';
    const body = {
        input: {
            input_image: imageUrl,
            prompt: prompt,
            aspect_ratio: aspectRatio, // Use provided aspect ratio or match_input_image
            output_format: "png",
            output_quality: 80,
            safety_tolerance: 2
        }
    };
    
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${replicateApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        res.status(response.status).json(data);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Proxy endpoint for polling Replicate prediction status
app.post('/api/replicate-poll', async (req, res) => {
    const { getUrl, replicateApiKey } = req.body;
    if (!getUrl || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing getUrl or replicateApiKey' });
    }
    try {
        const response = await fetch(getUrl, {
            headers: { 'Authorization': `Bearer ${replicateApiKey}` }
        });
        const data = await response.json();
        res.status(response.status).json(data);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Video generation endpoint using seedance-1-pro
app.post('/api/replicate-video', async (req, res) => {
    const { prompt, imageUrl, replicateApiKey } = req.body;
    if (!prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing prompt or replicateApiKey' });
    }
    
    const endpoint = 'https://api.replicate.com/v1/models/bytedance/seedance-1-pro/predictions';
    const body = {
        input: {
            prompt: prompt,
            duration: 5,             // 5 seconds for faster generation
            resolution: "1080p",     // High quality
            aspect_ratio: "16:9",
            fps: 24,
            camera_fixed: false
        }
    };
    
    // If imageUrl is provided, add it for image-to-video generation
    if (imageUrl) {
        body.input.image = imageUrl;
    }
    
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${replicateApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        res.status(response.status).json(data);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// RunwayML Gen-4 with reference images endpoint
app.post('/api/replicate-gen4', async (req, res) => {
    const { prompt, referenceImages, referenceTags, replicateApiKey, aspectRatio = '1:1' } = req.body;
    
    if (!prompt || !replicateApiKey) {
        return res.status(400).json({ error: 'Missing prompt or replicateApiKey' });
    }
    
    if (!replicateApiKey.startsWith('r8_')) {
        return res.status(400).json({ error: 'Invalid Replicate API key' });
    }
    
    if (referenceImages && referenceImages.length > 3) {
        return res.status(400).json({ error: 'Maximum 3 reference images allowed' });
    }
    
    const endpoint = 'https://api.replicate.com/v1/models/runwayml/gen4-image/predictions';
    const body = {
        input: {
            prompt: prompt,
            resolution: "1080p",
            aspect_ratio: aspectRatio // Use provided aspect ratio (1:1, 16:9, 9:16)
        }
    };
    
    // Add reference images and tags if provided
    if (referenceImages && referenceImages.length > 0) {
        body.input.reference_images = referenceImages;
    }
    
    if (referenceTags && referenceTags.length > 0) {
        body.input.reference_tags = referenceTags;
    }
    
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${replicateApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        
        const data = await response.json();
        res.status(response.status).json(data);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log(`Replicate proxy server running on port ${PORT}`));


---
File: /infinite_canvas_v5/style.css
---

/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background-color: #1a1a1a;
    color: #e0e0e0;
    overflow: hidden;
}

.app-container {
    position: relative;
    width: 100vw;
    height: 100vh;
}

/* Canvas styles */
#canvas {
    display: block;
    background-color: #2a2a2a;
    border: 1px solid #404040;
    cursor: grab;
    width: 100%;
    height: 100%;
}

#canvas:active {
    cursor: grabbing;
}



/* Toolbar buttons (now used in panel footer) */

.toolbar-btn {
    background: #0d7377;
    color: #ffffff;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.toolbar-btn:hover {
    background: #14a085;
}

.toolbar-btn:active {
    transform: translateY(1px);
}

.toolbar-btn:disabled {
    background: #555555;
    cursor: not-allowed;
    opacity: 0.7;
}

/* Canvas navigation controls */
.canvas-controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #333333;
    border: 1px solid #505050;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 1000;
}

.control-btn {
    background: #444444;
    color: #e0e0e0;
    border: 1px solid #666666;
    border-radius: 4px;
    width: 36px;
    height: 36px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
}

.control-icon {
    width: 20px;
    height: 20px;
    filter: brightness(0) saturate(100%) invert(88%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(88%) contrast(88%);
    transition: filter 0.2s ease;
}

.control-btn:hover {
    background: #555555;
    border-color: #777777;
}

.control-btn:hover .control-icon {
    filter: brightness(0) saturate(100%) invert(100%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(100%) contrast(100%);
}

.control-btn:active {
    transform: translateY(1px);
}

.control-separator {
    height: 1px;
    background-color: #666666;
    margin: 4px 0;
}

.control-btn:disabled {
    background-color: #2a2a2a;
    color: #666666;
    cursor: not-allowed;
    opacity: 0.6;
}

.control-btn:disabled .control-icon {
    filter: brightness(0) saturate(100%) invert(40%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(40%) contrast(40%);
}

.control-btn:disabled:hover {
    background-color: #2a2a2a;
    border-color: #444444;
}

.control-btn:disabled:hover .control-icon {
    filter: brightness(0) saturate(100%) invert(40%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(40%) contrast(40%);
}

/* Node styles (for reference, actual nodes are drawn on canvas) */
.node-input {
    position: absolute;
    border: 2px solid #0d7377;
    border-radius: 4px;
    padding: 8px;
    font-family: inherit;
    background: #2a2a2a;
    color: #e0e0e0;
    outline: none;
    z-index: 2000;
}

/* Generate Ideas tooltip */
.generate-ideas-tooltip {
    position: absolute;
    z-index: 2000;
    pointer-events: none;
    transition: opacity 0.2s ease;
    display: flex;
    gap: 8px;
}

.generate-ideas-tooltip.hidden {
    display: none;
}

.generate-ideas-btn, .expand-content-btn {
    background: #0d7377;
    color: #ffffff;
    border: none;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    pointer-events: auto;
    position: relative;
    min-width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.expand-content-btn {
    background: #6c5ce7;
}

.generate-ideas-btn:hover {
    background: #14a085;
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
}

.expand-content-btn:hover {
    background: #a29bfe;
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
}

.generate-ideas-btn:active, .expand-content-btn:active {
    transform: translateY(0);
}

.generate-ideas-btn:disabled {
    background: #555555;
    cursor: not-allowed;
    opacity: 0.7;
}

/* Tooltip arrow - only show on the first button */
.generate-ideas-btn::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid #0d7377;
}

.generate-ideas-btn:hover::after {
    border-top-color: #14a085;
}

/* Content Modal */
.content-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.content-modal.hidden {
    display: none;
}

.modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
}

.modal-container {
    position: relative;
    background: #2a2a2a;
    border-radius: 12px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
    max-width: 80vw;
    max-height: 80vh;
    width: 800px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 24px;
    border-bottom: 1px solid #444;
    background: #333;
}

.modal-header-buttons {
    display: flex;
    gap: 8px;
    align-items: center;
}

.modal-header h3 {
    margin: 0;
    color: #ffffff;
    font-size: 18px;
    font-weight: 600;
}

.edit-modal-btn {
    background: #0d7377;
    border: none;
    color: #ffffff;
    font-size: 16px;
    cursor: pointer;
    padding: 6px 10px;
    border-radius: 4px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 32px;
    height: 32px;
}

.edit-modal-btn:hover {
    background: #14a085;
    transform: translateY(-1px);
}

.edit-modal-btn:active {
    transform: translateY(0);
}

.close-modal-btn {
    background: none;
    border: none;
    color: #ffffff;
    font-size: 24px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.2s ease;
}

.close-modal-btn:hover {
    background: #555;
}

.modal-body {
    flex: 1;
    overflow: auto;
    padding: 24px;
}

.modal-content-text {
    color: #ffffff;
    font-size: 16px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Modal content HTML styling */
.modal-content-text h1,
.modal-content-text h2,
.modal-content-text h3 {
    color: #ffffff;
    margin: 0 0 16px 0;
    font-weight: bold;
}

.modal-content-text h1 {
    font-size: 24px;
}

.modal-content-text h2 {
    font-size: 20px;
}

.modal-content-text h3 {
    font-size: 18px;
}

.modal-content-text p {
    margin: 0 0 12px 0;
    color: #ffffff;
}

.modal-content-text ul {
    margin: 0 0 12px 0;
    padding-left: 20px;
}

.modal-content-text li {
    margin: 4px 0;
    color: #ffffff;
}

.modal-content-text strong {
    font-weight: bold;
    color: #ffffff;
}

.modal-content-text em {
    font-style: italic;
    color: #ffffff;
}

.modal-content-text code {
    background: #444;
    color: #ffd700;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
}

/* Modal edit textarea */
.modal-edit-textarea {
    width: 100%;
    min-height: 200px;
    max-height: 400px;
    background: #1a1a1a;
    color: #ffffff;
    border: 2px solid #0d7377;
    border-radius: 6px;
    padding: 16px;
    font-family: inherit;
    font-size: 16px;
    line-height: 1.6;
    resize: vertical;
    outline: none;
    transition: border-color 0.2s ease;
}

.modal-edit-textarea:focus {
    border-color: #14a085;
    box-shadow: 0 0 0 3px rgba(13, 115, 119, 0.1);
}

/* Modal edit controls */
.modal-edit-controls {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid #444;
}

.modal-save-btn, .modal-cancel-btn {
    background: #0d7377;
    color: #ffffff;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.modal-cancel-btn {
    background: #666;
}

.modal-save-btn:hover {
    background: #14a085;
}

.modal-cancel-btn:hover {
    background: #777;
}

.modal-save-btn:active, .modal-cancel-btn:active {
    transform: translateY(1px);
}

/* Selection status indicator */
.selection-status {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: #ffffff;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    z-index: 1500;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: all 0.2s ease;
}

.selection-status.hidden {
    display: none;
}

.selection-hint {
    display: block;
    margin-top: 4px;
    font-size: 12px;
    color: #9ca3af;
    font-weight: normal;
}

/* Navigation help */
.navigation-help {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: #ffffff;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 12px;
    z-index: 1500;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: opacity 0.3s ease;
}

.help-item {
    margin: 4px 0;
    display: flex;
    align-items: center;
    gap: 8px;
}

.navigation-help:hover {
    opacity: 0.7;
}

/* Utility classes */
.hidden {
    display: none;
}

.no-select {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

/* Undo/redo buttons now use the same styling as other control buttons */

/* API Key Modal */
.api-key-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.modal-content {
    background: #333333;
    border: 1px solid #505050;
    border-radius: 12px;
    padding: 24px;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
}

.modal-content h3 {
    color: #e0e0e0;
    margin-bottom: 12px;
    font-size: 18px;
    font-weight: 600;
}

.modal-content p {
    color: #b0b0b0;
    margin-bottom: 16px;
    font-size: 14px;
    line-height: 1.5;
}

.modal-content label {
    color: #e0e0e0;
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 6px;
    margin-top: 12px;
    display: block;
}

.modal-content label:first-of-type {
    margin-top: 0;
}

.modal-content input {
    width: 100%;
    padding: 12px;
    border: 1px solid #666666;
    border-radius: 6px;
    background: #2a2a2a;
    color: #e0e0e0;
    font-size: 14px;
    margin-bottom: 16px;
    outline: none;
    transition: border-color 0.2s ease;
}

.modal-content input:focus {
    border-color: #0d7377;
}

.modal-buttons {
    display: flex;
    gap: 12px;
    margin-bottom: 12px;
}

.modal-buttons button {
    flex: 1;
    padding: 10px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.modal-buttons button:first-child {
    background: #0d7377;
    color: #ffffff;
}

.modal-buttons button:first-child:hover {
    background: #14a085;
}

.modal-buttons button:last-child {
    background: #666666;
    color: #e0e0e0;
}

.modal-buttons button:last-child:hover {
    background: #777777;
}

.modal-content small {
    color: #888888;
    font-size: 12px;
}

/* Demo Mode Section */
.demo-mode-section {
    background: #2a2a2a;
    border: 1px solid #404040;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
}

.demo-toggle {
    display: flex;
    align-items: center;
    cursor: pointer;
    margin-bottom: 8px;
}

.demo-toggle input[type="checkbox"] {
    margin-right: 10px;
    transform: scale(1.2);
}

.demo-toggle-text {
    color: #e0e0e0;
    font-weight: 500;
    font-size: 14px;
}

.demo-description {
    color: #b0b0b0;
    font-size: 13px;
    margin: 0;
    line-height: 1.4;
}

#apiConfigSection {
    transition: opacity 0.3s ease;
}

#apiConfigSection[style*="none"] {
    opacity: 0;
}

/* Notifications */
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 16px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    z-index: 10000;
    max-width: 300px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    animation: slideIn 0.3s ease-out;
}

.notification-success {
    background: #0d7377;
    color: #ffffff;
}

.notification-error {
    background: #dc3545;
    color: #ffffff;
}

.notification-warning {
    background: #ffc107;
    color: #000000;
}

.notification-info {
    background: #17a2b8;
    color: #ffffff;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}
/* Model Selector Panel */
.model-selector-panel {
    position: fixed;
    top: 20px; /* Position at top for better visibility */
    left: 20px; /* Move to left side */
    width: 300px; /* Slightly wider for better readability */
    background: #333333;
    border: 1px solid #505050;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    color: #e0e0e0;
    transition: all 0.3s ease;
    animation: slideInLeft 0.4s ease-out;
}

.model-selector-panel.dragging {
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
    transform: scale(1.02);
    z-index: 1001;
}

@keyframes slideInLeft {
    from {
        transform: translateX(-100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.model-selector-panel .panel-header {
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #404040;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    border-bottom: 1px solid #505050;
    user-select: none;
    position: relative;
}

.drag-handle {
    position: absolute;
    left: 8px;
    top: 50%;
    transform: translateY(-50%);
    cursor: grab;
    padding: 4px;
    border-radius: 3px;
    transition: all 0.2s ease;
    opacity: 0.6;
}

.drag-handle:hover {
    background: rgba(255, 255, 255, 0.1);
    opacity: 1;
}

.drag-handle:active {
    cursor: grabbing;
    background: rgba(255, 255, 255, 0.2);
}

.drag-icon {
    font-size: 14px;
    color: #e0e0e0;
    font-weight: bold;
    line-height: 1;
    letter-spacing: -2px;
}

.model-selector-panel .header-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.model-selector-panel .active-count {
    font-size: 11px;
    color: #4ade80;
    font-weight: 500;
    background: rgba(74, 222, 128, 0.1);
    padding: 2px 6px;
    border-radius: 10px;
    border: 1px solid rgba(74, 222, 128, 0.3);
}

.model-selector-panel .panel-header:hover {
    background: #454545;
}

.model-selector-panel .panel-header h5 {
    margin: 0;
    margin-left: 32px; /* Make room for drag handle */
    font-size: 14px;
    font-weight: 600;
    color: #ffffff;
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
}

.model-selector-panel .toggle-btn {
    background: none;
    border: none;
    color: #e0e0e0;
    font-size: 12px;
    cursor: pointer;
    padding: 2px 6px;
    border-radius: 3px;
    transition: all 0.2s ease;
}

.model-selector-panel .toggle-btn:hover {
    background: #555555;
    color: #ffffff;
}

.model-selector-panel .panel-content {
    padding: 12px;
    max-height: 220px;
    overflow-y: auto;
    transition: all 0.3s ease;
}

.model-selector-panel .panel-content.collapsed {
    max-height: 0;
    padding: 0 12px;
    overflow: hidden;
}

.model-selector-panel .panel-footer {
    padding: 12px;
    border-top: 1px solid #505050;
    background: #3a3a3a;
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
    display: flex;
    justify-content: center;
}

.model-selector-panel .manage-btn {
    padding: 6px 12px;
    background: #0d7377;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.model-selector-panel .manage-btn:hover {
    background: #0a5d61;
    transform: translateY(-1px);
}

.section-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 0;
    margin: 8px 0 6px 0;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid #505050;
}

.section-header.active-section {
    color: #4ade80;
}

.section-header.inactive-section {
    color: #9ca3af;
}

.section-header .section-icon {
    font-size: 14px;
}

.model-checkbox-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    padding: 8px 10px;
    border-radius: 6px;
    transition: all 0.2s ease;
    border: 1px solid transparent;
}

.model-checkbox-item.active {
    background: rgba(74, 222, 128, 0.1);
    border-color: rgba(74, 222, 128, 0.3);
}

.model-checkbox-item.inactive {
    background: rgba(156, 163, 175, 0.05);
    border-color: rgba(156, 163, 175, 0.2);
}

.model-checkbox-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.model-checkbox-item.active:hover {
    background: rgba(74, 222, 128, 0.15);
    border-color: rgba(74, 222, 128, 0.4);
}

.model-checkbox-item.inactive:hover {
    background: rgba(156, 163, 175, 0.1);
    border-color: rgba(156, 163, 175, 0.3);
}

.model-checkbox-item:last-child {
    margin-bottom: 6px;
}

.model-checkbox-item input[type="checkbox"] {
    margin: 0 10px 0 0;
    transform: scale(1.1);
    cursor: pointer;
}

.model-checkbox-item label {
    cursor: pointer;
    flex: 1;
    font-size: 13px;
    color: #e0e0e0;
    display: flex;
    align-items: center;
    gap: 8px;
    line-height: 1.3;
}

.model-name {
    font-weight: 500;
    color: #ffffff;
}

.model-tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.model-tag.thinking {
    background: #ffc107;
    color: #000;
}

.model-tag.free {
    background: #28a745;
    color: #fff;
}

.model-panel-actions {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #505050;
    display: flex;
    gap: 8px;
}

.model-panel-btn {
    flex: 1;
    padding: 8px 12px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: all 0.2s ease;
}

.model-panel-btn.primary {
    background: #4ade80;
    color: #000;
}

.model-panel-btn.primary:hover {
    background: #22c55e;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
}

.model-panel-btn.secondary {
    background: #6b7280;
    color: white;
}

.model-panel-btn.secondary:hover {
    background: #4b5563;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(107, 114, 128, 0.3);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .model-selector-panel {
        width: 280px; /* Maintain good width on mobile */
        left: 10px; /* Adjust left margin for mobile */
        top: 10px; /* Adjust top margin for mobile */
    }

    .model-selector-panel .panel-content {
        max-height: 180px;
    }
}
/* Modal sections */
.modal-section {
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #2a2a2a;
}

.modal-section h4 {
    margin: 0 0 12px 0;
    color: #ffffff;
    font-size: 16px;
    font-weight: 600;
}

/* Configuration subsections for better organization */
.config-subsection {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid #555;
    border-radius: 6px;
    background: #252525;
}

.config-subsection h5 {
    margin: 0 0 15px 0;
    color: #f0f0f0;
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 2px solid #0d7377;
    padding-bottom: 6px;
    display: inline-block;
}

/* Visual distinction for different model types */
.modal-section:first-of-type {
    border-left: 4px solid #4a90e2;
    background: linear-gradient(135deg, #2a2a2a 0%, #2e3440 100%);
}

.modal-section:nth-of-type(2) {
    border-left: 4px solid #e24a90;
    background: linear-gradient(135deg, #2a2a2a 0%, #402e34 100%);
}

/* Modal action buttons */
.modal-action-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.modal-action-btn {
    background: #0d7377;
    color: #ffffff;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.modal-action-btn:hover {
    background: #14a085;
    transform: translateY(-1px);
}

.modal-action-btn:active {
    transform: translateY(0);
}

.generate-ideas-btn:hover::after {
    opacity: 1;
}

/* Aspect Ratio Selector */
.aspect-ratio-selector {
    position: absolute;
    z-index: 2001;
    background: #333333;
    border: 1px solid #555555;
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    min-width: 120px;
    transition: opacity 0.2s ease;
}

.aspect-ratio-selector::before {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    z-index: -1;
    /* Invisible padding area for better hover detection */
}

.aspect-ratio-selector.hidden {
    display: none;
}

.aspect-ratio-header {
    font-size: 12px;
    font-weight: 600;
    color: #bbb;
    margin-bottom: 6px;
    text-align: center;
}

.aspect-ratio-options {
    display: flex;
    gap: 4px;
}

.aspect-ratio-option {
    background: #444444;
    color: #e0e0e0;
    border: 1px solid #666666;
    border-radius: 4px;
    padding: 6px 10px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    flex: 1;
    text-align: center;
}

.aspect-ratio-option:hover {
    background: #555555;
    border-color: #777777;
}

.aspect-ratio-option.active {
    background: #0d7377;
    border-color: #0d7377;
    color: #ffffff;
}

.aspect-ratio-option.active:hover {
    background: #14a085;
    border-color: #14a085;
}


---
File: /infinite_canvas_v5/vercel.json
---

{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "installCommand": "npm install",
  "framework": "vite",
  "rewrites": [
    {
      "source": "/api/replicate-image",
      "destination": "/api/replicate-proxy"
    },
    {
      "source": "/api/replicate-context",
      "destination": "/api/replicate-proxy"
    },
    {
      "source": "/api/replicate-poll",
      "destination": "/api/replicate-proxy"
    },
    {
      "source": "/api/replicate-video",
      "destination": "/api/replicate-proxy"
    },
    {
      "source": "/api/replicate-gen4",
      "destination": "/api/replicate-proxy"
    }
  ]
}



---
File: /infinite_canvas_v5/vite.config.js
---

import { defineConfig } from 'vite'

export default defineConfig({
  // Ensure environment variables with VITE_ prefix are available in the browser
  define: {
    // Make sure environment variables are properly exposed
    'process.env': {}
  },
  
  // Development server configuration
  server: {
    port: 3000,
    open: true,
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,
        secure: false
      }
    }
  },
  
  // Build configuration
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['openai']
        }
      }
    }
  },
  
  // Environment variables configuration
  envPrefix: 'VITE_'
})

